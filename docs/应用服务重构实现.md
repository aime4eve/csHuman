# 应用服务重构实现

## 1. 概述

本文档详细描述了微调生命周期工作流系统中应用服务层的重构实现，遵循洋葱模型架构原则，将业务逻辑移至领域层，应用服务专注于协调和编排。

## 2. 重构原则

### 2.1 应用服务职责
- **协调编排**：协调多个聚合根和领域服务
- **事务管理**：管理跨聚合根的事务边界
- **异常处理**：处理和转换异常
- **DTO转换**：处理输入输出数据转换
- **权限验证**：执行访问控制检查

### 2.2 不应包含的内容
- **业务规则**：移至领域层
- **数据访问**：委托给仓储
- **外部服务调用**：通过领域服务接口

## 3. 知识管理应用服务重构

### 3.1 重构前的问题
```python
# 重构前：应用服务包含过多业务逻辑
class KnowledgeManagementService:
    def create_knowledge_base(self, request):
        # 业务验证逻辑（应该在领域层）
        if not request.name or len(request.name) < 3:
            raise ValueError("Name too short")
        
        # 重复性检查（应该在领域层）
        existing = self.repository.find_by_name(request.name)
        if existing:
            raise ValueError("Name already exists")
        
        # 直接操作数据（应该通过聚合根）
        kb = KnowledgeBase()
        kb.name = request.name
        kb.status = "CREATED"
        kb.created_at = datetime.now()
        
        self.repository.save(kb)
        return kb.id
```

### 3.2 重构后的实现
```python
from typing import Dict, Any, List, Optional
from uuid import UUID
from dataclasses import dataclass
from datetime import datetime

# 命令对象
@dataclass
class CreateKnowledgeBaseCommand:
    """创建知识库命令"""
    name: str
    description: str
    owner_id: UUID
    tags: List[str] = None
    config: Dict[str, Any] = None

@dataclass
class AddDocumentCommand:
    """添加文档命令"""
    knowledge_base_id: UUID
    title: str
    content: str
    file_type: str
    metadata: Dict[str, Any] = None

@dataclass
class BuildVectorStoreCommand:
    """构建向量存储命令"""
    knowledge_base_id: UUID
    embedding_model: str
    chunk_size: int = 1000
    chunk_overlap: int = 200

# 查询对象
@dataclass
class KnowledgeBaseQuery:
    """知识库查询"""
    id: Optional[UUID] = None
    name: Optional[str] = None
    owner_id: Optional[UUID] = None
    status: Optional[str] = None
    tags: Optional[List[str]] = None

# DTO对象
@dataclass
class KnowledgeBaseDto:
    """知识库DTO"""
    id: UUID
    name: str
    description: str
    status: str
    document_count: int
    total_size_bytes: int
    created_at: datetime
    updated_at: datetime
    owner_id: UUID
    tags: List[str]

@dataclass
class DocumentDto:
    """文档DTO"""
    id: UUID
    title: str
    file_type: str
    size_bytes: int
    status: str
    created_at: datetime
    metadata: Dict[str, Any]

# 重构后的应用服务
class KnowledgeManagementApplicationService:
    """知识管理应用服务"""
    
    def __init__(self,
                 kb_repository: IKnowledgeBaseRepository,
                 doc_processing_service: IDocumentProcessingService,
                 vector_store_service: IVectorStoreService,
                 storage_service: IStorageService,
                 notification_service: INotificationService,
                 unit_of_work: IUnitOfWork):
        self._kb_repository = kb_repository
        self._doc_processing_service = doc_processing_service
        self._vector_store_service = vector_store_service
        self._storage_service = storage_service
        self._notification_service = notification_service
        self._unit_of_work = unit_of_work
    
    def create_knowledge_base(self, command: CreateKnowledgeBaseCommand) -> UUID:
        """创建知识库"""
        try:
            with self._unit_of_work:
                # 检查权限（应用层职责）
                self._check_create_permission(command.owner_id)
                
                # 创建聚合根（业务逻辑在领域层）
                kb = KnowledgeBase.create(
                    name=command.name,
                    description=command.description,
                    owner_id=command.owner_id,
                    tags=command.tags or [],
                    config=command.config or {}
                )
                
                # 检查名称唯一性（领域层业务规则）
                existing_kb = self._kb_repository.find_by_name(command.name)
                if existing_kb:
                    raise DomainException("Knowledge base name already exists")
                
                # 保存聚合根
                self._kb_repository.save(kb)
                
                # 发布领域事件
                self._publish_domain_events(kb)
                
                # 提交事务
                self._unit_of_work.commit()
                
                # 发送通知（基础设施关注点）
                self._notification_service.send_email(
                    to=self._get_owner_email(command.owner_id),
                    subject="Knowledge Base Created",
                    content=f"Knowledge base '{command.name}' has been created successfully."
                )
                
                return kb.id
                
        except DomainException as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Failed to create knowledge base: {e.message}")
        except Exception as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Unexpected error: {str(e)}")
    
    def add_document(self, command: AddDocumentCommand) -> UUID:
        """添加文档"""
        try:
            with self._unit_of_work:
                # 获取知识库聚合根
                kb = self._kb_repository.find_by_id(command.knowledge_base_id)
                if not kb:
                    raise ApplicationException("Knowledge base not found")
                
                # 检查权限
                self._check_modify_permission(kb.owner_id)
                
                # 创建文档实体
                document = Document.create(
                    title=command.title,
                    content=command.content,
                    file_type=command.file_type,
                    metadata=command.metadata or {}
                )
                
                # 文档处理（领域服务）
                processed_content = self._doc_processing_service.process_document(document)
                document.update_processed_content(processed_content)
                
                # 添加到知识库（业务逻辑在聚合根）
                kb.add_document(document)
                
                # 保存文档内容到存储
                file_path = f"documents/{document.id}"
                self._storage_service.save_file(file_path, command.content.encode())
                
                # 保存聚合根
                self._kb_repository.save(kb)
                
                # 发布领域事件
                self._publish_domain_events(kb)
                
                # 提交事务
                self._unit_of_work.commit()
                
                return document.id
                
        except DomainException as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Failed to add document: {e.message}")
        except Exception as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Unexpected error: {str(e)}")
    
    def build_vector_store(self, command: BuildVectorStoreCommand) -> None:
        """构建向量存储"""
        try:
            with self._unit_of_work:
                # 获取知识库聚合根
                kb = self._kb_repository.find_by_id(command.knowledge_base_id)
                if not kb:
                    raise ApplicationException("Knowledge base not found")
                
                # 检查权限
                self._check_modify_permission(kb.owner_id)
                
                # 构建向量存储（业务逻辑在聚合根）
                kb.build_vector_store(
                    embedding_model=command.embedding_model,
                    chunk_size=command.chunk_size,
                    chunk_overlap=command.chunk_overlap,
                    vector_store_service=self._vector_store_service
                )
                
                # 保存聚合根
                self._kb_repository.save(kb)
                
                # 发布领域事件
                self._publish_domain_events(kb)
                
                # 提交事务
                self._unit_of_work.commit()
                
        except DomainException as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Failed to build vector store: {e.message}")
        except Exception as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Unexpected error: {str(e)}")
    
    def get_knowledge_base(self, query: KnowledgeBaseQuery) -> Optional[KnowledgeBaseDto]:
        """获取知识库"""
        try:
            kb = None
            
            if query.id:
                kb = self._kb_repository.find_by_id(query.id)
            elif query.name:
                kb = self._kb_repository.find_by_name(query.name)
            
            if not kb:
                return None
            
            # 检查读取权限
            self._check_read_permission(kb.owner_id)
            
            # 转换为DTO
            return self._map_to_dto(kb)
            
        except Exception as e:
            raise ApplicationException(f"Failed to get knowledge base: {str(e)}")
    
    def search_knowledge_bases(self, query: KnowledgeBaseQuery) -> List[KnowledgeBaseDto]:
        """搜索知识库"""
        try:
            # 构建查询条件
            knowledge_bases = []
            
            if query.owner_id:
                knowledge_bases = self._kb_repository.find_by_owner_id(query.owner_id)
            elif query.status:
                knowledge_bases = self._kb_repository.find_by_status(query.status)
            elif query.tags:
                knowledge_bases = self._kb_repository.find_by_tags(query.tags)
            else:
                knowledge_bases = self._kb_repository.find_all()
            
            # 过滤权限
            accessible_kbs = [kb for kb in knowledge_bases 
                            if self._has_read_permission(kb.owner_id)]
            
            # 转换为DTO
            return [self._map_to_dto(kb) for kb in accessible_kbs]
            
        except Exception as e:
            raise ApplicationException(f"Failed to search knowledge bases: {str(e)}")
    
    # 私有辅助方法
    def _check_create_permission(self, owner_id: UUID) -> None:
        """检查创建权限"""
        # 实现权限检查逻辑
        pass
    
    def _check_modify_permission(self, owner_id: UUID) -> None:
        """检查修改权限"""
        # 实现权限检查逻辑
        pass
    
    def _check_read_permission(self, owner_id: UUID) -> None:
        """检查读取权限"""
        # 实现权限检查逻辑
        pass
    
    def _has_read_permission(self, owner_id: UUID) -> bool:
        """检查是否有读取权限"""
        # 实现权限检查逻辑
        return True
    
    def _get_owner_email(self, owner_id: UUID) -> str:
        """获取所有者邮箱"""
        # 实现用户信息获取逻辑
        return "user@example.com"
    
    def _publish_domain_events(self, aggregate: Any) -> None:
        """发布领域事件"""
        events = aggregate.get_domain_events()
        for event in events:
            # 发布事件到消息队列
            pass
        aggregate.clear_domain_events()
    
    def _map_to_dto(self, kb: 'KnowledgeBase') -> KnowledgeBaseDto:
        """映射到DTO"""
        return KnowledgeBaseDto(
            id=kb.id,
            name=kb.name,
            description=kb.description,
            status=kb.status,
            document_count=kb.document_count,
            total_size_bytes=kb.total_size_bytes,
            created_at=kb.created_at,
            updated_at=kb.updated_at,
            owner_id=kb.owner_id,
            tags=kb.tags
        )
```

## 4. 模型训练应用服务重构

### 4.1 命令和查询对象
```python
@dataclass
class StartFineTuningCommand:
    """启动微调命令"""
    knowledge_base_id: UUID
    base_model: str
    training_config: Dict[str, Any]
    owner_id: UUID

@dataclass
class StartIncrementalTrainingCommand:
    """启动增量训练命令"""
    base_model_id: UUID
    new_data_id: UUID
    training_config: Dict[str, Any]
    owner_id: UUID

@dataclass
class TrainingJobDto:
    """训练任务DTO"""
    id: UUID
    job_type: str
    status: str
    progress_percentage: float
    current_epoch: int
    total_epochs: int
    created_at: datetime
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    model_path: Optional[str]
    error_message: Optional[str]
```

### 4.2 重构后的训练应用服务
```python
class ModelTrainingApplicationService:
    """模型训练应用服务"""
    
    def __init__(self,
                 training_job_repository: ITrainingJobRepository,
                 kb_repository: IKnowledgeBaseRepository,
                 training_service: IModelTrainingService,
                 storage_service: IStorageService,
                 notification_service: INotificationService,
                 unit_of_work: IUnitOfWork):
        self._training_job_repository = training_job_repository
        self._kb_repository = kb_repository
        self._training_service = training_service
        self._storage_service = storage_service
        self._notification_service = notification_service
        self._unit_of_work = unit_of_work
    
    def start_fine_tuning(self, command: StartFineTuningCommand) -> UUID:
        """启动微调训练"""
        try:
            with self._unit_of_work:
                # 检查权限
                self._check_training_permission(command.owner_id)
                
                # 获取知识库
                kb = self._kb_repository.find_by_id(command.knowledge_base_id)
                if not kb:
                    raise ApplicationException("Knowledge base not found")
                
                # 验证知识库状态（业务逻辑在聚合根）
                if not kb.is_ready_for_training():
                    raise ApplicationException("Knowledge base is not ready for training")
                
                # 创建训练任务聚合根
                training_job = TrainingJob.create_fine_tuning_job(
                    knowledge_base_id=command.knowledge_base_id,
                    base_model=command.base_model,
                    training_config=command.training_config,
                    owner_id=command.owner_id
                )
                
                # 启动训练（业务逻辑在聚合根）
                training_job.start_training(self._training_service)
                
                # 保存训练任务
                self._training_job_repository.save(training_job)
                
                # 发布领域事件
                self._publish_domain_events(training_job)
                
                # 提交事务
                self._unit_of_work.commit()
                
                return training_job.id
                
        except DomainException as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Failed to start fine-tuning: {e.message}")
        except Exception as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Unexpected error: {str(e)}")
    
    def start_incremental_training(self, command: StartIncrementalTrainingCommand) -> UUID:
        """启动增量训练"""
        try:
            with self._unit_of_work:
                # 检查权限
                self._check_training_permission(command.owner_id)
                
                # 获取基础模型训练任务
                base_job = self._training_job_repository.find_by_id(command.base_model_id)
                if not base_job:
                    raise ApplicationException("Base model not found")
                
                # 获取新数据知识库
                new_data_kb = self._kb_repository.find_by_id(command.new_data_id)
                if not new_data_kb:
                    raise ApplicationException("New data knowledge base not found")
                
                # 创建增量训练任务
                training_job = TrainingJob.create_incremental_training_job(
                    base_model_id=command.base_model_id,
                    new_data_id=command.new_data_id,
                    training_config=command.training_config,
                    owner_id=command.owner_id
                )
                
                # 验证增量训练兼容性（业务逻辑在聚合根）
                if not training_job.is_compatible_with_base_model(base_job):
                    raise ApplicationException("Incompatible with base model")
                
                # 启动训练
                training_job.start_training(self._training_service)
                
                # 保存训练任务
                self._training_job_repository.save(training_job)
                
                # 发布领域事件
                self._publish_domain_events(training_job)
                
                # 提交事务
                self._unit_of_work.commit()
                
                return training_job.id
                
        except DomainException as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Failed to start incremental training: {e.message}")
        except Exception as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Unexpected error: {str(e)}")
    
    def monitor_training(self, job_id: UUID) -> TrainingJobDto:
        """监控训练进度"""
        try:
            # 获取训练任务
            training_job = self._training_job_repository.find_by_id(job_id)
            if not training_job:
                raise ApplicationException("Training job not found")
            
            # 检查权限
            self._check_read_permission(training_job.owner_id)
            
            # 更新训练进度（业务逻辑在聚合根）
            if training_job.is_in_progress():
                progress = self._training_service.get_training_progress(str(job_id))
                training_job.update_progress(progress)
                self._training_job_repository.save(training_job)
            
            # 转换为DTO
            return self._map_training_job_to_dto(training_job)
            
        except Exception as e:
            raise ApplicationException(f"Failed to monitor training: {str(e)}")
    
    def cancel_training(self, job_id: UUID, owner_id: UUID) -> None:
        """取消训练"""
        try:
            with self._unit_of_work:
                # 获取训练任务
                training_job = self._training_job_repository.find_by_id(job_id)
                if not training_job:
                    raise ApplicationException("Training job not found")
                
                # 检查权限
                self._check_modify_permission(training_job.owner_id, owner_id)
                
                # 取消训练（业务逻辑在聚合根）
                training_job.cancel_training(self._training_service)
                
                # 保存训练任务
                self._training_job_repository.save(training_job)
                
                # 发布领域事件
                self._publish_domain_events(training_job)
                
                # 提交事务
                self._unit_of_work.commit()
                
        except DomainException as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Failed to cancel training: {e.message}")
        except Exception as e:
            self._unit_of_work.rollback()
            raise ApplicationException(f"Unexpected error: {str(e)}")
    
    # 私有辅助方法
    def _check_training_permission(self, owner_id: UUID) -> None:
        """检查训练权限"""
        pass
    
    def _check_read_permission(self, owner_id: UUID) -> None:
        """检查读取权限"""
        pass
    
    def _check_modify_permission(self, resource_owner_id: UUID, requester_id: UUID) -> None:
        """检查修改权限"""
        if resource_owner_id != requester_id:
            raise ApplicationException("Access denied")
    
    def _publish_domain_events(self, aggregate: Any) -> None:
        """发布领域事件"""
        events = aggregate.get_domain_events()
        for event in events:
            # 发布事件到消息队列
            pass
        aggregate.clear_domain_events()
    
    def _map_training_job_to_dto(self, job: 'TrainingJob') -> TrainingJobDto:
        """映射到DTO"""
        return TrainingJobDto(
            id=job.id,
            job_type=job.job_type,
            status=job.status,
            progress_percentage=job.progress_percentage,
            current_epoch=job.current_epoch,
            total_epochs=job.total_epochs,
            created_at=job.created_at,
            started_at=job.started_at,
            completed_at=job.completed_at,
            model_path=job.final_model_path,
            error_message=job.error_message
        )
```

## 5. 工作单元模式实现

### 5.1 工作单元接口
```python
from abc import ABC, abstractmethod
from typing import List, Any

class IUnitOfWork(ABC):
    """工作单元接口"""
    
    @abstractmethod
    def begin(self) -> None:
        """开始事务"""
        pass
    
    @abstractmethod
    def commit(self) -> None:
        """提交事务"""
        pass
    
    @abstractmethod
    def rollback(self) -> None:
        """回滚事务"""
        pass
    
    @abstractmethod
    def register_new(self, entity: Any) -> None:
        """注册新实体"""
        pass
    
    @abstractmethod
    def register_dirty(self, entity: Any) -> None:
        """注册脏实体"""
        pass
    
    @abstractmethod
    def register_removed(self, entity: Any) -> None:
        """注册删除实体"""
        pass
    
    def __enter__(self):
        self.begin()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            self.commit()
        else:
            self.rollback()
```

### 5.2 工作单元实现
```python
class DatabaseUnitOfWork(IUnitOfWork):
    """数据库工作单元实现"""
    
    def __init__(self, session_factory):
        self._session_factory = session_factory
        self._session = None
        self._new_entities: List[Any] = []
        self._dirty_entities: List[Any] = []
        self._removed_entities: List[Any] = []
    
    def begin(self) -> None:
        """开始事务"""
        self._session = self._session_factory()
        self._session.begin()
    
    def commit(self) -> None:
        """提交事务"""
        try:
            # 处理新实体
            for entity in self._new_entities:
                self._session.add(entity)
            
            # 处理脏实体
            for entity in self._dirty_entities:
                self._session.merge(entity)
            
            # 处理删除实体
            for entity in self._removed_entities:
                self._session.delete(entity)
            
            # 提交事务
            self._session.commit()
            
        except Exception as e:
            self._session.rollback()
            raise e
        finally:
            self._cleanup()
    
    def rollback(self) -> None:
        """回滚事务"""
        if self._session:
            self._session.rollback()
        self._cleanup()
    
    def register_new(self, entity: Any) -> None:
        """注册新实体"""
        self._new_entities.append(entity)
    
    def register_dirty(self, entity: Any) -> None:
        """注册脏实体"""
        self._dirty_entities.append(entity)
    
    def register_removed(self, entity: Any) -> None:
        """注册删除实体"""
        self._removed_entities.append(entity)
    
    def _cleanup(self) -> None:
        """清理资源"""
        if self._session:
            self._session.close()
            self._session = None
        
        self._new_entities.clear()
        self._dirty_entities.clear()
        self._removed_entities.clear()
```

## 6. 异常处理策略

### 6.1 异常层次结构
```python
class ApplicationException(Exception):
    """应用层异常基类"""
    
    def __init__(self, message: str, inner_exception: Exception = None):
        super().__init__(message)
        self.message = message
        self.inner_exception = inner_exception

class DomainException(Exception):
    """领域层异常基类"""
    
    def __init__(self, message: str):
        super().__init__(message)
        self.message = message

class ValidationException(ApplicationException):
    """验证异常"""
    
    def __init__(self, field: str, message: str):
        super().__init__(f"Validation failed for field '{field}': {message}")
        self.field = field

class AuthorizationException(ApplicationException):
    """授权异常"""
    
    def __init__(self, message: str = "Access denied"):
        super().__init__(message)

class ResourceNotFoundException(ApplicationException):
    """资源未找到异常"""
    
    def __init__(self, resource_type: str, resource_id: str):
        super().__init__(f"{resource_type} with id '{resource_id}' not found")
        self.resource_type = resource_type
        self.resource_id = resource_id
```

### 6.2 异常处理装饰器
```python
from functools import wraps
import logging

def handle_application_exceptions(func):
    """应用异常处理装饰器"""
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except DomainException as e:
            logging.error(f"Domain exception in {func.__name__}: {e.message}")
            raise ApplicationException(f"Business rule violation: {e.message}", e)
        except ValidationException as e:
            logging.warning(f"Validation exception in {func.__name__}: {e.message}")
            raise e
        except AuthorizationException as e:
            logging.warning(f"Authorization exception in {func.__name__}: {e.message}")
            raise e
        except ResourceNotFoundException as e:
            logging.warning(f"Resource not found in {func.__name__}: {e.message}")
            raise e
        except Exception as e:
            logging.error(f"Unexpected exception in {func.__name__}: {str(e)}")
            raise ApplicationException(f"An unexpected error occurred: {str(e)}", e)
    
    return wrapper
```

## 7. 总结

通过应用服务重构，我们实现了：

1. **职责分离**：应用服务专注于协调编排，业务逻辑移至领域层
2. **事务管理**：通过工作单元模式管理事务边界
3. **异常处理**：建立了完整的异常处理体系
4. **DTO转换**：清晰的输入输出数据转换
5. **权限控制**：在应用层实现访问控制
6. **事件发布**：协调领域事件的发布

这种重构确保了应用服务的精简和职责明确，为系统的可维护性和可测试性奠定了基础。