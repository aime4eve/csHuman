# 防腐层(Anti-Corruption Layer)设计

## 1. 设计概述

防腐层是洋葱模型架构中的关键组件，用于隔离外部系统的复杂性，保护领域模型的纯净性。本设计包含外部系统防腐层和微服务间防腐层两个层面。

## 2. 外部系统防腐层

### 2.1 第三方模型服务防腐层

#### 2.1.1 统一模型服务接口
```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

class ModelType(Enum):
    """模型类型枚举"""
    EMBEDDING = "embedding"
    CHAT = "chat"
    COMPLETION = "completion"
    FINE_TUNED = "fine_tuned"

@dataclass
class ModelRequest:
    """模型请求统一格式"""
    model_id: str
    input_text: str
    parameters: Dict[str, Any]
    model_type: ModelType
    max_tokens: Optional[int] = None
    temperature: Optional[float] = None

@dataclass
class ModelResponse:
    """模型响应统一格式"""
    model_id: str
    output: Any
    usage: Dict[str, int]
    latency_ms: int
    success: bool
    error_message: Optional[str] = None

class IModelService(ABC):
    """模型服务统一接口"""
    
    @abstractmethod
    def invoke_model(self, request: ModelRequest) -> ModelResponse:
        """调用模型"""
        pass
    
    @abstractmethod
    def get_available_models(self) -> List[str]:
        """获取可用模型列表"""
        pass
    
    @abstractmethod
    def health_check(self) -> bool:
        """健康检查"""
        pass
```

#### 2.1.2 HuggingFace API防腐层
```python
import requests
from typing import List, Dict, Any
import time
from .model_service_interface import IModelService, ModelRequest, ModelResponse, ModelType

class HuggingFaceAntiCorruptionLayer(IModelService):
    """HuggingFace API防腐层"""
    
    def __init__(self, api_token: str, base_url: str = "https://api-inference.huggingface.co"):
        self.api_token = api_token
        self.base_url = base_url
        self.headers = {"Authorization": f"Bearer {api_token}"}
    
    def invoke_model(self, request: ModelRequest) -> ModelResponse:
        """调用HuggingFace模型"""
        start_time = time.time()
        
        try:
            # 转换请求格式
            hf_request = self._convert_to_hf_format(request)
            
            # 调用HuggingFace API
            url = f"{self.base_url}/models/{request.model_id}"
            response = requests.post(url, headers=self.headers, json=hf_request)
            
            if response.status_code == 200:
                hf_response = response.json()
                # 转换响应格式
                return self._convert_from_hf_format(request, hf_response, start_time)
            else:
                return ModelResponse(
                    model_id=request.model_id,
                    output=None,
                    usage={"total_tokens": 0},
                    latency_ms=int((time.time() - start_time) * 1000),
                    success=False,
                    error_message=f"HuggingFace API错误: {response.status_code} - {response.text}"
                )
        
        except Exception as e:
            return ModelResponse(
                model_id=request.model_id,
                output=None,
                usage={"total_tokens": 0},
                latency_ms=int((time.time() - start_time) * 1000),
                success=False,
                error_message=f"调用HuggingFace API异常: {str(e)}"
            )
    
    def get_available_models(self) -> List[str]:
        """获取可用模型列表"""
        # 预定义的可用模型列表
        return [
            "sentence-transformers/all-MiniLM-L6-v2",
            "microsoft/DialoGPT-medium",
            "TinyLlama/TinyLlama-1.1B-Chat-v1.0"
        ]
    
    def health_check(self) -> bool:
        """健康检查"""
        try:
            response = requests.get(f"{self.base_url}/models", headers=self.headers, timeout=5)
            return response.status_code == 200
        except:
            return False
    
    def _convert_to_hf_format(self, request: ModelRequest) -> Dict[str, Any]:
        """转换为HuggingFace格式"""
        if request.model_type == ModelType.EMBEDDING:
            return {
                "inputs": request.input_text,
                "options": {"wait_for_model": True}
            }
        elif request.model_type == ModelType.CHAT:
            return {
                "inputs": request.input_text,
                "parameters": {
                    "max_new_tokens": request.max_tokens or 100,
                    "temperature": request.temperature or 0.7,
                    **request.parameters
                }
            }
        else:
            return {"inputs": request.input_text}
    
    def _convert_from_hf_format(self, request: ModelRequest, hf_response: Any, start_time: float) -> ModelResponse:
        """从HuggingFace格式转换"""
        latency_ms = int((time.time() - start_time) * 1000)
        
        if request.model_type == ModelType.EMBEDDING:
            # 嵌入向量响应
            return ModelResponse(
                model_id=request.model_id,
                output=hf_response,  # 直接返回向量
                usage={"total_tokens": len(request.input_text.split())},
                latency_ms=latency_ms,
                success=True
            )
        elif request.model_type == ModelType.CHAT:
            # 聊天响应
            generated_text = hf_response[0].get("generated_text", "") if hf_response else ""
            return ModelResponse(
                model_id=request.model_id,
                output=generated_text,
                usage={"total_tokens": len(generated_text.split())},
                latency_ms=latency_ms,
                success=True
            )
        else:
            return ModelResponse(
                model_id=request.model_id,
                output=hf_response,
                usage={"total_tokens": 0},
                latency_ms=latency_ms,
                success=True
            )
```

#### 2.1.3 OpenAI API防腐层
```python
import openai
from typing import List, Dict, Any
import time
from .model_service_interface import IModelService, ModelRequest, ModelResponse, ModelType

class OpenAIAntiCorruptionLayer(IModelService):
    """OpenAI API防腐层"""
    
    def __init__(self, api_key: str, base_url: str = None):
        self.client = openai.OpenAI(api_key=api_key, base_url=base_url)
    
    def invoke_model(self, request: ModelRequest) -> ModelResponse:
        """调用OpenAI模型"""
        start_time = time.time()
        
        try:
            if request.model_type == ModelType.EMBEDDING:
                response = self.client.embeddings.create(
                    model=request.model_id,
                    input=request.input_text
                )
                return ModelResponse(
                    model_id=request.model_id,
                    output=response.data[0].embedding,
                    usage={"total_tokens": response.usage.total_tokens},
                    latency_ms=int((time.time() - start_time) * 1000),
                    success=True
                )
            
            elif request.model_type == ModelType.CHAT:
                response = self.client.chat.completions.create(
                    model=request.model_id,
                    messages=[{"role": "user", "content": request.input_text}],
                    max_tokens=request.max_tokens or 100,
                    temperature=request.temperature or 0.7
                )
                return ModelResponse(
                    model_id=request.model_id,
                    output=response.choices[0].message.content,
                    usage={"total_tokens": response.usage.total_tokens},
                    latency_ms=int((time.time() - start_time) * 1000),
                    success=True
                )
            
            else:
                raise ValueError(f"不支持的模型类型: {request.model_type}")
        
        except Exception as e:
            return ModelResponse(
                model_id=request.model_id,
                output=None,
                usage={"total_tokens": 0},
                latency_ms=int((time.time() - start_time) * 1000),
                success=False,
                error_message=f"调用OpenAI API异常: {str(e)}"
            )
    
    def get_available_models(self) -> List[str]:
        """获取可用模型列表"""
        try:
            models = self.client.models.list()
            return [model.id for model in models.data]
        except:
            return ["gpt-3.5-turbo", "text-embedding-ada-002"]
    
    def health_check(self) -> bool:
        """健康检查"""
        try:
            self.client.models.list()
            return True
        except:
            return False
```

#### 2.1.4 本地模型服务防腐层
```python
import requests
from typing import List, Dict, Any
import time
from .model_service_interface import IModelService, ModelRequest, ModelResponse, ModelType

class LocalModelAntiCorruptionLayer(IModelService):
    """本地模型服务防腐层"""
    
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
    
    def invoke_model(self, request: ModelRequest) -> ModelResponse:
        """调用本地模型"""
        start_time = time.time()
        
        try:
            # 转换请求格式
            local_request = self._convert_to_local_format(request)
            
            # 调用本地模型API
            url = f"{self.base_url}/v1/models/{request.model_id}/invoke"
            response = requests.post(url, json=local_request, timeout=30)
            
            if response.status_code == 200:
                local_response = response.json()
                return self._convert_from_local_format(request, local_response, start_time)
            else:
                return ModelResponse(
                    model_id=request.model_id,
                    output=None,
                    usage={"total_tokens": 0},
                    latency_ms=int((time.time() - start_time) * 1000),
                    success=False,
                    error_message=f"本地模型服务错误: {response.status_code}"
                )
        
        except Exception as e:
            return ModelResponse(
                model_id=request.model_id,
                output=None,
                usage={"total_tokens": 0},
                latency_ms=int((time.time() - start_time) * 1000),
                success=False,
                error_message=f"调用本地模型异常: {str(e)}"
            )
    
    def get_available_models(self) -> List[str]:
        """获取可用模型列表"""
        try:
            response = requests.get(f"{self.base_url}/v1/models")
            if response.status_code == 200:
                return response.json().get("models", [])
        except:
            pass
        return []
    
    def health_check(self) -> bool:
        """健康检查"""
        try:
            response = requests.get(f"{self.base_url}/health", timeout=5)
            return response.status_code == 200
        except:
            return False
    
    def _convert_to_local_format(self, request: ModelRequest) -> Dict[str, Any]:
        """转换为本地格式"""
        return {
            "input": request.input_text,
            "model_type": request.model_type.value,
            "parameters": {
                "max_tokens": request.max_tokens,
                "temperature": request.temperature,
                **request.parameters
            }
        }
    
    def _convert_from_local_format(self, request: ModelRequest, local_response: Dict[str, Any], start_time: float) -> ModelResponse:
        """从本地格式转换"""
        return ModelResponse(
            model_id=request.model_id,
            output=local_response.get("output"),
            usage=local_response.get("usage", {"total_tokens": 0}),
            latency_ms=int((time.time() - start_time) * 1000),
            success=local_response.get("success", True)
        )
```

### 2.2 存储系统防腐层

#### 2.2.1 统一存储接口
```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, Union
from dataclasses import dataclass
from enum import Enum

class StorageType(Enum):
    """存储类型枚举"""
    RELATIONAL = "relational"
    VECTOR = "vector"
    OBJECT = "object"
    CACHE = "cache"

@dataclass
class StorageQuery:
    """存储查询统一格式"""
    query_type: str
    parameters: Dict[str, Any]
    filters: Optional[Dict[str, Any]] = None
    limit: Optional[int] = None
    offset: Optional[int] = None

@dataclass
class StorageResult:
    """存储结果统一格式"""
    data: Any
    count: int
    success: bool
    error_message: Optional[str] = None

class IStorageService(ABC):
    """存储服务统一接口"""
    
    @abstractmethod
    def store(self, key: str, data: Any, metadata: Optional[Dict[str, Any]] = None) -> bool:
        """存储数据"""
        pass
    
    @abstractmethod
    def retrieve(self, key: str) -> Optional[Any]:
        """检索数据"""
        pass
    
    @abstractmethod
    def query(self, query: StorageQuery) -> StorageResult:
        """查询数据"""
        pass
    
    @abstractmethod
    def delete(self, key: str) -> bool:
        """删除数据"""
        pass
    
    @abstractmethod
    def health_check(self) -> bool:
        """健康检查"""
        pass
```

#### 2.2.2 关系型数据库防腐层
```python
import psycopg2
from psycopg2.extras import RealDictCursor
from typing import List, Dict, Any, Optional
import json
from .storage_interface import IStorageService, StorageQuery, StorageResult, StorageType

class PostgreSQLAntiCorruptionLayer(IStorageService):
    """PostgreSQL防腐层"""
    
    def __init__(self, connection_string: str):
        self.connection_string = connection_string
        self._connection = None
    
    def _get_connection(self):
        """获取数据库连接"""
        if self._connection is None or self._connection.closed:
            self._connection = psycopg2.connect(self.connection_string)
        return self._connection
    
    def store(self, key: str, data: Any, metadata: Optional[Dict[str, Any]] = None) -> bool:
        """存储数据"""
        try:
            conn = self._get_connection()
            with conn.cursor() as cursor:
                # 将数据序列化为JSON
                json_data = json.dumps(data) if not isinstance(data, str) else data
                json_metadata = json.dumps(metadata) if metadata else None
                
                cursor.execute(
                    "INSERT INTO storage_data (key, data, metadata, created_at) VALUES (%s, %s, %s, NOW()) ON CONFLICT (key) DO UPDATE SET data = %s, metadata = %s, updated_at = NOW()",
                    (key, json_data, json_metadata, json_data, json_metadata)
                )
                conn.commit()
                return True
        except Exception as e:
            print(f"存储数据失败: {e}")
            return False
    
    def retrieve(self, key: str) -> Optional[Any]:
        """检索数据"""
        try:
            conn = self._get_connection()
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("SELECT data FROM storage_data WHERE key = %s", (key,))
                result = cursor.fetchone()
                if result:
                    return json.loads(result['data'])
                return None
        except Exception as e:
            print(f"检索数据失败: {e}")
            return None
    
    def query(self, query: StorageQuery) -> StorageResult:
        """查询数据"""
        try:
            conn = self._get_connection()
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                # 构建SQL查询
                sql, params = self._build_sql_query(query)
                cursor.execute(sql, params)
                results = cursor.fetchall()
                
                return StorageResult(
                    data=[dict(row) for row in results],
                    count=len(results),
                    success=True
                )
        except Exception as e:
            return StorageResult(
                data=[],
                count=0,
                success=False,
                error_message=str(e)
            )
    
    def delete(self, key: str) -> bool:
        """删除数据"""
        try:
            conn = self._get_connection()
            with conn.cursor() as cursor:
                cursor.execute("DELETE FROM storage_data WHERE key = %s", (key,))
                conn.commit()
                return True
        except Exception as e:
            print(f"删除数据失败: {e}")
            return False
    
    def health_check(self) -> bool:
        """健康检查"""
        try:
            conn = self._get_connection()
            with conn.cursor() as cursor:
                cursor.execute("SELECT 1")
                return True
        except:
            return False
    
    def _build_sql_query(self, query: StorageQuery) -> tuple:
        """构建SQL查询"""
        base_sql = "SELECT * FROM storage_data"
        params = []
        
        if query.filters:
            where_clauses = []
            for key, value in query.filters.items():
                where_clauses.append(f"{key} = %s")
                params.append(value)
            
            if where_clauses:
                base_sql += " WHERE " + " AND ".join(where_clauses)
        
        if query.limit:
            base_sql += " LIMIT %s"
            params.append(query.limit)
        
        if query.offset:
            base_sql += " OFFSET %s"
            params.append(query.offset)
        
        return base_sql, params
```

#### 2.2.3 向量数据库防腐层
```python
import faiss
import numpy as np
from typing import List, Dict, Any, Optional, Tuple
import pickle
import os
from .storage_interface import IStorageService, StorageQuery, StorageResult

class FAISSAntiCorruptionLayer(IStorageService):
    """FAISS向量数据库防腐层"""
    
    def __init__(self, index_path: str, dimension: int = 768):
        self.index_path = index_path
        self.dimension = dimension
        self.index = None
        self.id_to_key = {}
        self.key_to_id = {}
        self.metadata_store = {}
        self._load_index()
    
    def _load_index(self):
        """加载索引"""
        if os.path.exists(self.index_path):
            self.index = faiss.read_index(self.index_path)
            # 加载元数据
            metadata_path = self.index_path + ".metadata"
            if os.path.exists(metadata_path):
                with open(metadata_path, 'rb') as f:
                    data = pickle.load(f)
                    self.id_to_key = data.get('id_to_key', {})
                    self.key_to_id = data.get('key_to_id', {})
                    self.metadata_store = data.get('metadata_store', {})
        else:
            self.index = faiss.IndexFlatIP(self.dimension)
    
    def _save_index(self):
        """保存索引"""
        faiss.write_index(self.index, self.index_path)
        # 保存元数据
        metadata_path = self.index_path + ".metadata"
        with open(metadata_path, 'wb') as f:
            pickle.dump({
                'id_to_key': self.id_to_key,
                'key_to_id': self.key_to_id,
                'metadata_store': self.metadata_store
            }, f)
    
    def store(self, key: str, data: Any, metadata: Optional[Dict[str, Any]] = None) -> bool:
        """存储向量数据"""
        try:
            if not isinstance(data, np.ndarray):
                data = np.array(data, dtype=np.float32)
            
            if data.shape[-1] != self.dimension:
                raise ValueError(f"向量维度不匹配: 期望 {self.dimension}, 实际 {data.shape[-1]}")
            
            # 如果key已存在，先删除
            if key in self.key_to_id:
                self.delete(key)
            
            # 添加向量
            vector = data.reshape(1, -1)
            vector_id = self.index.ntotal
            self.index.add(vector)
            
            # 更新映射
            self.id_to_key[vector_id] = key
            self.key_to_id[key] = vector_id
            
            # 存储元数据
            if metadata:
                self.metadata_store[key] = metadata
            
            self._save_index()
            return True
        
        except Exception as e:
            print(f"存储向量失败: {e}")
            return False
    
    def retrieve(self, key: str) -> Optional[Any]:
        """检索向量数据"""
        try:
            if key not in self.key_to_id:
                return None
            
            vector_id = self.key_to_id[key]
            vector = self.index.reconstruct(vector_id)
            return vector
        
        except Exception as e:
            print(f"检索向量失败: {e}")
            return None
    
    def query(self, query: StorageQuery) -> StorageResult:
        """向量相似性查询"""
        try:
            if query.query_type == "similarity":
                query_vector = np.array(query.parameters["vector"], dtype=np.float32).reshape(1, -1)
                k = query.parameters.get("k", 10)
                
                scores, indices = self.index.search(query_vector, k)
                
                results = []
                for i, (score, idx) in enumerate(zip(scores[0], indices[0])):
                    if idx != -1 and idx in self.id_to_key:
                        key = self.id_to_key[idx]
                        result = {
                            "key": key,
                            "score": float(score),
                            "vector": self.index.reconstruct(idx).tolist()
                        }
                        if key in self.metadata_store:
                            result["metadata"] = self.metadata_store[key]
                        results.append(result)
                
                return StorageResult(
                    data=results,
                    count=len(results),
                    success=True
                )
            else:
                return StorageResult(
                    data=[],
                    count=0,
                    success=False,
                    error_message=f"不支持的查询类型: {query.query_type}"
                )
        
        except Exception as e:
            return StorageResult(
                data=[],
                count=0,
                success=False,
                error_message=str(e)
            )
    
    def delete(self, key: str) -> bool:
        """删除向量数据"""
        try:
            if key not in self.key_to_id:
                return True
            
            vector_id = self.key_to_id[key]
            
            # FAISS不支持直接删除，需要重建索引
            # 这里简化处理，只从映射中删除
            del self.key_to_id[key]
            del self.id_to_key[vector_id]
            
            if key in self.metadata_store:
                del self.metadata_store[key]
            
            self._save_index()
            return True
        
        except Exception as e:
            print(f"删除向量失败: {e}")
            return False
    
    def health_check(self) -> bool:
        """健康检查"""
        try:
            return self.index is not None and self.index.ntotal >= 0
        except:
            return False
```

### 2.3 消息系统防腐层

#### 2.3.1 统一消息接口
```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, Callable
from dataclasses import dataclass
from enum import Enum

class MessageType(Enum):
    """消息类型枚举"""
    COMMAND = "command"
    EVENT = "event"
    QUERY = "query"
    NOTIFICATION = "notification"

@dataclass
class Message:
    """消息统一格式"""
    id: str
    topic: str
    payload: Dict[str, Any]
    message_type: MessageType
    timestamp: float
    headers: Optional[Dict[str, str]] = None
    correlation_id: Optional[str] = None

class IMessageService(ABC):
    """消息服务统一接口"""
    
    @abstractmethod
    def publish(self, message: Message) -> bool:
        """发布消息"""
        pass
    
    @abstractmethod
    def subscribe(self, topic: str, handler: Callable[[Message], None]) -> bool:
        """订阅消息"""
        pass
    
    @abstractmethod
    def unsubscribe(self, topic: str) -> bool:
        """取消订阅"""
        pass
    
    @abstractmethod
    def health_check(self) -> bool:
        """健康检查"""
        pass
```

#### 2.3.2 RabbitMQ防腐层
```python
import pika
import json
import uuid
from typing import Dict, Any, Callable
import time
from .message_interface import IMessageService, Message, MessageType

class RabbitMQAntiCorruptionLayer(IMessageService):
    """RabbitMQ防腐层"""
    
    def __init__(self, connection_url: str):
        self.connection_url = connection_url
        self.connection = None
        self.channel = None
        self.subscribers = {}
        self._connect()
    
    def _connect(self):
        """建立连接"""
        try:
            self.connection = pika.BlockingConnection(pika.URLParameters(self.connection_url))
            self.channel = self.connection.channel()
        except Exception as e:
            print(f"连接RabbitMQ失败: {e}")
    
    def publish(self, message: Message) -> bool:
        """发布消息"""
        try:
            if not self.channel:
                self._connect()
            
            # 声明交换机和队列
            self.channel.exchange_declare(exchange=message.topic, exchange_type='topic')
            
            # 转换消息格式
            rabbitmq_message = self._convert_to_rabbitmq_format(message)
            
            # 发布消息
            self.channel.basic_publish(
                exchange=message.topic,
                routing_key=message.topic,
                body=json.dumps(rabbitmq_message),
                properties=pika.BasicProperties(
                    message_id=message.id,
                    timestamp=int(message.timestamp),
                    headers=message.headers or {}
                )
            )
            return True
        
        except Exception as e:
            print(f"发布消息失败: {e}")
            return False
    
    def subscribe(self, topic: str, handler: Callable[[Message], None]) -> bool:
        """订阅消息"""
        try:
            if not self.channel:
                self._connect()
            
            # 声明交换机和队列
            self.channel.exchange_declare(exchange=topic, exchange_type='topic')
            result = self.channel.queue_declare(queue='', exclusive=True)
            queue_name = result.method.queue
            
            self.channel.queue_bind(exchange=topic, queue=queue_name, routing_key=topic)
            
            # 包装处理器
            def wrapped_handler(ch, method, properties, body):
                try:
                    rabbitmq_message = json.loads(body)
                    message = self._convert_from_rabbitmq_format(rabbitmq_message, properties)
                    handler(message)
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                except Exception as e:
                    print(f"处理消息失败: {e}")
                    ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
            
            self.channel.basic_consume(queue=queue_name, on_message_callback=wrapped_handler)
            self.subscribers[topic] = queue_name
            
            return True
        
        except Exception as e:
            print(f"订阅消息失败: {e}")
            return False
    
    def unsubscribe(self, topic: str) -> bool:
        """取消订阅"""
        try:
            if topic in self.subscribers:
                queue_name = self.subscribers[topic]
                self.channel.queue_delete(queue=queue_name)
                del self.subscribers[topic]
            return True
        except Exception as e:
            print(f"取消订阅失败: {e}")
            return False
    
    def health_check(self) -> bool:
        """健康检查"""
        try:
            if not self.connection or self.connection.is_closed:
                self._connect()
            return self.connection and not self.connection.is_closed
        except:
            return False
    
    def _convert_to_rabbitmq_format(self, message: Message) -> Dict[str, Any]:
        """转换为RabbitMQ格式"""
        return {
            "id": message.id,
            "topic": message.topic,
            "payload": message.payload,
            "message_type": message.message_type.value,
            "timestamp": message.timestamp,
            "correlation_id": message.correlation_id
        }
    
    def _convert_from_rabbitmq_format(self, rabbitmq_message: Dict[str, Any], properties) -> Message:
        """从RabbitMQ格式转换"""
        return Message(
            id=rabbitmq_message["id"],
            topic=rabbitmq_message["topic"],
            payload=rabbitmq_message["payload"],
            message_type=MessageType(rabbitmq_message["message_type"]),
            timestamp=rabbitmq_message["timestamp"],
            headers=dict(properties.headers) if properties.headers else None,
            correlation_id=rabbitmq_message.get("correlation_id")
        )
```

## 3. 微服务间防腐层

### 3.1 服务间通信防腐层

#### 3.1.1 统一服务客户端接口
```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

class ServiceType(Enum):
    """服务类型枚举"""
    KNOWLEDGE_MANAGEMENT = "knowledge_management"
    MODEL_TRAINING = "model_training"
    QUALITY_ASSESSMENT = "quality_assessment"
    APPLICATION_SERVICE = "application_service"

@dataclass
class ServiceRequest:
    """服务请求统一格式"""
    service_type: ServiceType
    operation: str
    parameters: Dict[str, Any]
    headers: Optional[Dict[str, str]] = None
    timeout: Optional[int] = None

@dataclass
class ServiceResponse:
    """服务响应统一格式"""
    success: bool
    data: Any
    error_code: Optional[str] = None
    error_message: Optional[str] = None
    headers: Optional[Dict[str, str]] = None

class IServiceClient(ABC):
    """服务客户端统一接口"""
    
    @abstractmethod
    def call(self, request: ServiceRequest) -> ServiceResponse:
        """调用服务"""
        pass
    
    @abstractmethod
    def health_check(self) -> bool:
        """健康检查"""
        pass
```

#### 3.1.2 知识管理服务客户端防腐层
```python
import requests
from typing import Dict, Any
import time
from .service_client_interface import IServiceClient, ServiceRequest, ServiceResponse, ServiceType

class KnowledgeManagementClientACL(IServiceClient):
    """知识管理服务客户端防腐层"""
    
    def __init__(self, base_url: str, api_key: str = None):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.headers = {"Content-Type": "application/json"}
        if api_key:
            self.headers["Authorization"] = f"Bearer {api_key}"
    
    def call(self, request: ServiceRequest) -> ServiceResponse:
        """调用知识管理服务"""
        try:
            # 转换请求格式
            url, method, payload = self._convert_request(request)
            
            # 发送HTTP请求
            response = requests.request(
                method=method,
                url=url,
                json=payload,
                headers={**self.headers, **(request.headers or {})},
                timeout=request.timeout or 30
            )
            
            # 转换响应格式
            return self._convert_response(response)
        
        except Exception as e:
            return ServiceResponse(
                success=False,
                data=None,
                error_code="CLIENT_ERROR",
                error_message=str(e)
            )
    
    def health_check(self) -> bool:
        """健康检查"""
        try:
            response = requests.get(f"{self.base_url}/health", timeout=5)
            return response.status_code == 200
        except:
            return False
    
    def _convert_request(self, request: ServiceRequest) -> tuple:
        """转换请求格式"""
        operation = request.operation
        params = request.parameters
        
        if operation == "create_knowledge_base":
            return f"{self.base_url}/api/v1/knowledge-bases", "POST", {
                "name": params["name"],
                "description": params.get("description", ""),
                "config": params.get("config", {})
            }
        
        elif operation == "add_documents":
            kb_id = params["knowledge_base_id"]
            return f"{self.base_url}/api/v1/knowledge-bases/{kb_id}/documents", "POST", {
                "documents": params["documents"]
            }
        
        elif operation == "build_vector_store":
            kb_id = params["knowledge_base_id"]
            return f"{self.base_url}/api/v1/knowledge-bases/{kb_id}/vector-store", "POST", {
                "rebuild": params.get("rebuild", False)
            }
        
        elif operation == "search_documents":
            kb_id = params["knowledge_base_id"]
            return f"{self.base_url}/api/v1/knowledge-bases/{kb_id}/search", "POST", {
                "query": params["query"],
                "top_k": params.get("top_k", 10),
                "filters": params.get("filters", {})
            }
        
        else:
            raise ValueError(f"不支持的操作: {operation}")
    
    def _convert_response(self, response: requests.Response) -> ServiceResponse:
        """转换响应格式"""
        try:
            if response.status_code == 200:
                data = response.json()
                return ServiceResponse(
                    success=True,
                    data=data,
                    headers=dict(response.headers)
                )
            else:
                error_data = response.json() if response.content else {}
                return ServiceResponse(
                    success=False,
                    data=None,
                    error_code=str(response.status_code),
                    error_message=error_data.get("message", response.text),
                    headers=dict(response.headers)
                )
        except Exception as e:
            return ServiceResponse(
                success=False,
                data=None,
                error_code="PARSE_ERROR",
                error_message=f"解析响应失败: {str(e)}"
            )
```

### 3.2 数据转换层

#### 3.2.1 DTO转换器
```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Type, TypeVar
from dataclasses import dataclass
import json
from datetime import datetime

T = TypeVar('T')

class IDataTransformer(ABC):
    """数据转换器接口"""
    
    @abstractmethod
    def to_internal(self, external_data: Any) -> Any:
        """外部数据转内部领域对象"""
        pass
    
    @abstractmethod
    def to_external(self, internal_data: Any) -> Any:
        """内部领域对象转外部数据"""
        pass

class KnowledgeBaseTransformer(IDataTransformer):
    """知识库数据转换器"""
    
    def to_internal(self, external_data: Dict[str, Any]) -> 'KnowledgeBase':
        """外部DTO转内部领域对象"""
        from domain.knowledge_management.knowledge_base import KnowledgeBase, KnowledgeBaseId
        
        return KnowledgeBase(
            id=KnowledgeBaseId(external_data["id"]),
            name=external_data["name"],
            description=external_data.get("description", ""),
            status=external_data.get("status", "created"),
            created_at=datetime.fromisoformat(external_data["created_at"]) if external_data.get("created_at") else datetime.utcnow(),
            updated_at=datetime.fromisoformat(external_data["updated_at"]) if external_data.get("updated_at") else datetime.utcnow(),
            document_count=external_data.get("document_count", 0),
            total_size_bytes=external_data.get("total_size_bytes", 0)
        )
    
    def to_external(self, internal_data: 'KnowledgeBase') -> Dict[str, Any]:
        """内部领域对象转外部DTO"""
        return {
            "id": str(internal_data.id),
            "name": internal_data.name,
            "description": internal_data.description,
            "status": internal_data.status,
            "created_at": internal_data.created_at.isoformat(),
            "updated_at": internal_data.updated_at.isoformat(),
            "document_count": internal_data.document_count,
            "total_size_bytes": internal_data.total_size_bytes,
            "is_ready": internal_data.is_ready()
        }

class TrainingJobTransformer(IDataTransformer):
    """训练任务数据转换器"""
    
    def to_internal(self, external_data: Dict[str, Any]) -> 'TrainingJob':
        """外部DTO转内部领域对象"""
        from domain.model_training.training_job import TrainingJob, TrainingJobId
        
        return TrainingJob(
            id=TrainingJobId(external_data["id"]),
            knowledge_base_id=external_data["knowledge_base_id"],
            model_config=external_data["model_config"],
            training_parameters=external_data["training_parameters"],
            status=external_data.get("status", "created"),
            created_at=datetime.fromisoformat(external_data["created_at"]) if external_data.get("created_at") else datetime.utcnow(),
            started_at=datetime.fromisoformat(external_data["started_at"]) if external_data.get("started_at") else None,
            completed_at=datetime.fromisoformat(external_data["completed_at"]) if external_data.get("completed_at") else None,
            progress_percentage=external_data.get("progress_percentage", 0.0),
            current_epoch=external_data.get("current_epoch", 0),
            total_epochs=external_data.get("total_epochs", 0)
        )
    
    def to_external(self, internal_data: 'TrainingJob') -> Dict[str, Any]:
        """内部领域对象转外部DTO"""
        return {
            "id": str(internal_data.id),
            "knowledge_base_id": internal_data.knowledge_base_id,
            "model_config": internal_data.model_config,
            "training_parameters": internal_data.training_parameters,
            "status": internal_data.status,
            "created_at": internal_data.created_at.isoformat(),
            "started_at": internal_data.started_at.isoformat() if internal_data.started_at else None,
            "completed_at": internal_data.completed_at.isoformat() if internal_data.completed_at else None,
            "progress_percentage": internal_data.progress_percentage,
            "current_epoch": internal_data.current_epoch,
            "total_epochs": internal_data.total_epochs,
            "is_completed": internal_data.is_completed_successfully(),
            "can_be_cancelled": internal_data.can_be_cancelled()
        }

class DataTransformationService:
    """数据转换服务"""
    
    def __init__(self):
        self.transformers = {
            "KnowledgeBase": KnowledgeBaseTransformer(),
            "TrainingJob": TrainingJobTransformer(),
            # 可以添加更多转换器
        }
    
    def register_transformer(self, entity_type: str, transformer: IDataTransformer):
        """注册转换器"""
        self.transformers[entity_type] = transformer
    
    def to_internal(self, entity_type: str, external_data: Any) -> Any:
        """转换为内部对象"""
        if entity_type not in self.transformers:
            raise ValueError(f"未找到 {entity_type} 的转换器")
        
        return self.transformers[entity_type].to_internal(external_data)
    
    def to_external(self, entity_type: str, internal_data: Any) -> Any:
        """转换为外部数据"""
        if entity_type not in self.transformers:
            raise ValueError(f"未找到 {entity_type} 的转换器")
        
        return self.transformers[entity_type].to_external(internal_data)
    
    def batch_to_internal(self, entity_type: str, external_data_list: List[Any]) -> List[Any]:
        """批量转换为内部对象"""
        return [self.to_internal(entity_type, data) for data in external_data_list]
    
    def batch_to_external(self, entity_type: str, internal_data_list: List[Any]) -> List[Any]:
        """批量转换为外部数据"""
        return [self.to_external(entity_type, data) for data in internal_data_list]
```

## 4. 防腐层集成配置

### 4.1 防腐层工厂
```python
from typing import Dict, Any, Optional
from enum import Enum

class ProviderType(Enum):
    """提供商类型"""
    HUGGINGFACE = "huggingface"
    OPENAI = "openai"
    LOCAL = "local"
    POSTGRESQL = "postgresql"
    FAISS = "faiss"
    RABBITMQ = "rabbitmq"
    REDIS = "redis"

class AntiCorruptionLayerFactory:
    """防腐层工厂"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
    
    def create_model_service(self, provider: ProviderType) -> IModelService:
        """创建模型服务防腐层"""
        if provider == ProviderType.HUGGINGFACE:
            return HuggingFaceAntiCorruptionLayer(
                api_token=self.config["huggingface"]["api_token"],
                base_url=self.config["huggingface"].get("base_url")
            )
        elif provider == ProviderType.OPENAI:
            return OpenAIAntiCorruptionLayer(
                api_key=self.config["openai"]["api_key"],
                base_url=self.config["openai"].get("base_url")
            )
        elif provider == ProviderType.LOCAL:
            return LocalModelAntiCorruptionLayer(
                base_url=self.config["local_model"]["base_url"]
            )
        else:
            raise ValueError(f"不支持的模型服务提供商: {provider}")
    
    def create_storage_service(self, provider: ProviderType) -> IStorageService:
        """创建存储服务防腐层"""
        if provider == ProviderType.POSTGRESQL:
            return PostgreSQLAntiCorruptionLayer(
                connection_string=self.config["postgresql"]["connection_string"]
            )
        elif provider == ProviderType.FAISS:
            return FAISSAntiCorruptionLayer(
                index_path=self.config["faiss"]["index_path"],
                dimension=self.config["faiss"]["dimension"]
            )
        else:
            raise ValueError(f"不支持的存储服务提供商: {provider}")
    
    def create_message_service(self, provider: ProviderType) -> IMessageService:
        """创建消息服务防腐层"""
        if provider == ProviderType.RABBITMQ:
            return RabbitMQAntiCorruptionLayer(
                connection_url=self.config["rabbitmq"]["connection_url"]
            )
        else:
            raise ValueError(f"不支持的消息服务提供商: {provider}")
    
    def create_service_client(self, service_type: ServiceType) -> IServiceClient:
        """创建服务客户端防腐层"""
        if service_type == ServiceType.KNOWLEDGE_MANAGEMENT:
            return KnowledgeManagementClientACL(
                base_url=self.config["services"]["knowledge_management"]["base_url"],
                api_key=self.config["services"]["knowledge_management"].get("api_key")
            )
        # 可以添加更多服务客户端
        else:
            raise ValueError(f"不支持的服务类型: {service_type}")
```

### 4.2 配置示例
```yaml
# anti_corruption_layer_config.yaml
huggingface:
  api_token: "your_hf_token"
  base_url: "https://api-inference.huggingface.co"

openai:
  api_key: "your_openai_key"
  base_url: null

local_model:
  base_url: "http://localhost:8000"

postgresql:
  connection_string: "postgresql://user:password@localhost:5432/dbname"

faiss:
  index_path: "/data/vector_store/index.faiss"
  dimension: 768

rabbitmq:
  connection_url: "amqp://user:password@localhost:5672/"

services:
  knowledge_management:
    base_url: "http://localhost:8001"
    api_key: "service_api_key"
  model_training:
    base_url: "http://localhost:8002"
    api_key: "service_api_key"
  quality_assessment:
    base_url: "http://localhost:8003"
    api_key: "service_api_key"
```

## 5. 总结

本防腐层设计实现了以下关键特性：

1. **统一接口**: 为不同的外部系统提供统一的接口，隔离实现细节
2. **数据转换**: 在外部格式和内部领域模型之间进行转换
3. **错误处理**: 统一的错误处理和异常转换
4. **配置化**: 支持通过配置文件灵活切换不同的实现
5. **可扩展性**: 易于添加新的外部系统适配器
6. **健康检查**: 内置健康检查机制，便于监控

通过这个防腐层设计，微调生命周期工作流系统能够有效地与各种外部系统集成，同时保持领域模型的纯净性和系统的可维护性。