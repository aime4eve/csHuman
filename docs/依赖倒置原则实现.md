# 依赖倒置原则实现设计

## 1. 概述

依赖倒置原则（Dependency Inversion Principle, DIP）是洋葱模型架构的核心原则之一。本文档详细设计了微调生命周期工作流系统中依赖倒置原则的实现方案，确保高层模块不依赖低层模块，两者都依赖于抽象。

## 2. 依赖方向设计

### 2.1 层级依赖关系

```
┌─────────────────────────────────────┐
│            接口层 (Interface)        │
│         ↓ (依赖)                    │
│           应用层 (Application)       │
│         ↓ (依赖)                    │
│            领域层 (Domain)          │
│         ↑ (实现)                    │
│         基础设施层 (Infrastructure)   │
└─────────────────────────────────────┘
```

### 2.2 依赖倒置实现策略

- **领域层**：定义抽象接口，不依赖任何外层
- **应用层**：依赖领域层接口，编排业务流程
- **基础设施层**：实现领域层定义的接口
- **接口层**：依赖应用层，处理外部请求

## 3. 领域层接口定义

### 3.1 仓储接口 (Repository Interfaces)

```python
from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any
from uuid import UUID
from datetime import datetime

# 基础仓储接口
class IRepository(ABC):
    """仓储基础接口"""
    
    @abstractmethod
    def save(self, entity: Any) -> None:
        """保存实体"""
        pass
    
    @abstractmethod
    def find_by_id(self, entity_id: UUID) -> Optional[Any]:
        """根据ID查找实体"""
        pass
    
    @abstractmethod
    def delete(self, entity_id: UUID) -> None:
        """删除实体"""
        pass

# 知识库仓储接口
class IKnowledgeBaseRepository(IRepository):
    """知识库仓储接口"""
    
    @abstractmethod
    def find_by_name(self, name: str) -> Optional['KnowledgeBase']:
        """根据名称查找知识库"""
        pass
    
    @abstractmethod
    def find_by_status(self, status: str) -> List['KnowledgeBase']:
        """根据状态查找知识库"""
        pass
    
    @abstractmethod
    def find_ready_for_training(self) -> List['KnowledgeBase']:
        """查找可用于训练的知识库"""
        pass

# 训练任务仓储接口
class ITrainingJobRepository(IRepository):
    """训练任务仓储接口"""
    
    @abstractmethod
    def find_by_status(self, status: str) -> List['TrainingJob']:
        """根据状态查找训练任务"""
        pass
    
    @abstractmethod
    def find_active_jobs(self) -> List['TrainingJob']:
        """查找活跃的训练任务"""
        pass
    
    @abstractmethod
    def find_by_knowledge_base_id(self, kb_id: UUID) -> List['TrainingJob']:
        """根据知识库ID查找训练任务"""
        pass

# 评估任务仓储接口
class IEvaluationJobRepository(IRepository):
    """评估任务仓储接口"""
    
    @abstractmethod
    def find_by_training_job_id(self, training_job_id: UUID) -> List['EvaluationJob']:
        """根据训练任务ID查找评估任务"""
        pass
    
    @abstractmethod
    def find_pending_evaluations(self) -> List['EvaluationJob']:
        """查找待执行的评估任务"""
        pass

# 工作流实例仓储接口
class IWorkflowInstanceRepository(IRepository):
    """工作流实例仓储接口"""
    
    @abstractmethod
    def find_by_workflow_type(self, workflow_type: str) -> List['WorkflowInstance']:
        """根据工作流类型查找实例"""
        pass
    
    @abstractmethod
    def find_running_workflows(self) -> List['WorkflowInstance']:
        """查找运行中的工作流"""
        pass
```

### 3.2 领域服务接口 (Domain Service Interfaces)

```python
# 文档处理服务接口
class IDocumentProcessingService(ABC):
    """文档处理服务接口"""
    
    @abstractmethod
    def extract_text(self, document: 'Document') -> str:
        """提取文档文本"""
        pass
    
    @abstractmethod
    def generate_embeddings(self, text: str) -> List[float]:
        """生成文本嵌入"""
        pass
    
    @abstractmethod
    def validate_document_format(self, document: 'Document') -> bool:
        """验证文档格式"""
        pass

# 模型训练服务接口
class IModelTrainingService(ABC):
    """模型训练服务接口"""
    
    @abstractmethod
    def start_training(self, training_job: 'TrainingJob') -> str:
        """启动训练任务"""
        pass
    
    @abstractmethod
    def monitor_training_progress(self, job_id: str) -> Dict[str, Any]:
        """监控训练进度"""
        pass
    
    @abstractmethod
    def stop_training(self, job_id: str) -> None:
        """停止训练任务"""
        pass

# 质量评估服务接口
class IQualityAssessmentService(ABC):
    """质量评估服务接口"""
    
    @abstractmethod
    def evaluate_model_quality(self, evaluation_job: 'EvaluationJob') -> Dict[str, float]:
        """评估模型质量"""
        pass
    
    @abstractmethod
    def compare_with_baseline(self, current_metrics: Dict[str, float], 
                            baseline_metrics: Dict[str, float]) -> Dict[str, Any]:
        """与基线模型比较"""
        pass

# 推理服务接口
class IInferenceService(ABC):
    """推理服务接口"""
    
    @abstractmethod
    def create_session(self, model_path: str) -> 'InferenceSession':
        """创建推理会话"""
        pass
    
    @abstractmethod
    def generate_response(self, session: 'InferenceSession', 
                         query: str, context: str) -> str:
        """生成响应"""
        pass
```

### 3.3 基础设施服务接口 (Infrastructure Service Interfaces)

```python
# 存储服务接口
class IStorageService(ABC):
    """存储服务接口"""
    
    @abstractmethod
    def save_file(self, file_path: str, content: bytes) -> str:
        """保存文件"""
        pass
    
    @abstractmethod
    def load_file(self, file_path: str) -> bytes:
        """加载文件"""
        pass
    
    @abstractmethod
    def delete_file(self, file_path: str) -> None:
        """删除文件"""
        pass

# 向量存储服务接口
class IVectorStoreService(ABC):
    """向量存储服务接口"""
    
    @abstractmethod
    def create_index(self, index_name: str, dimension: int) -> None:
        """创建索引"""
        pass
    
    @abstractmethod
    def add_vectors(self, index_name: str, vectors: List[List[float]], 
                   metadata: List[Dict[str, Any]]) -> None:
        """添加向量"""
        pass
    
    @abstractmethod
    def search_similar(self, index_name: str, query_vector: List[float], 
                      top_k: int) -> List[Dict[str, Any]]:
        """搜索相似向量"""
        pass

# 消息队列服务接口
class IMessageQueueService(ABC):
    """消息队列服务接口"""
    
    @abstractmethod
    def publish(self, topic: str, message: Dict[str, Any]) -> None:
        """发布消息"""
        pass
    
    @abstractmethod
    def subscribe(self, topic: str, callback: callable) -> None:
        """订阅消息"""
        pass

# 通知服务接口
class INotificationService(ABC):
    """通知服务接口"""
    
    @abstractmethod
    def send_email(self, to: str, subject: str, content: str) -> None:
        """发送邮件"""
        pass
    
    @abstractmethod
    def send_webhook(self, url: str, payload: Dict[str, Any]) -> None:
        """发送Webhook"""
        pass
```

## 4. 应用层端口接口

### 4.1 应用服务端口

```python
# 知识管理端口
class IKnowledgeManagementPort(ABC):
    """知识管理端口接口"""
    
    @abstractmethod
    def create_knowledge_base(self, name: str, description: str) -> UUID:
        """创建知识库"""
        pass
    
    @abstractmethod
    def add_document(self, kb_id: UUID, document_data: Dict[str, Any]) -> UUID:
        """添加文档"""
        pass
    
    @abstractmethod
    def build_vector_store(self, kb_id: UUID) -> None:
        """构建向量存储"""
        pass

# 模型训练端口
class IModelTrainingPort(ABC):
    """模型训练端口接口"""
    
    @abstractmethod
    def start_fine_tuning(self, kb_id: UUID, training_config: Dict[str, Any]) -> UUID:
        """启动微调训练"""
        pass
    
    @abstractmethod
    def start_incremental_training(self, base_model_id: UUID, 
                                 new_data_id: UUID) -> UUID:
        """启动增量训练"""
        pass
    
    @abstractmethod
    def monitor_training(self, job_id: UUID) -> Dict[str, Any]:
        """监控训练进度"""
        pass

# 质量评估端口
class IQualityAssessmentPort(ABC):
    """质量评估端口接口"""
    
    @abstractmethod
    def start_evaluation(self, model_id: UUID, test_dataset_id: UUID) -> UUID:
        """启动质量评估"""
        pass
    
    @abstractmethod
    def get_evaluation_results(self, evaluation_id: UUID) -> Dict[str, Any]:
        """获取评估结果"""
        pass

# 推理端口
class IInferencePort(ABC):
    """推理端口接口"""
    
    @abstractmethod
    def create_inference_session(self, model_id: UUID) -> UUID:
        """创建推理会话"""
        pass
    
    @abstractmethod
    def generate_response(self, session_id: UUID, query: str) -> str:
        """生成响应"""
        pass

# 工作流编排端口
class IWorkflowOrchestrationPort(ABC):
    """工作流编排端口接口"""
    
    @abstractmethod
    def start_fine_tuning_workflow(self, kb_id: UUID, 
                                 config: Dict[str, Any]) -> UUID:
        """启动微调工作流"""
        pass
    
    @abstractmethod
    def start_incremental_training_workflow(self, base_model_id: UUID, 
                                          new_data_id: UUID) -> UUID:
        """启动增量训练工作流"""
        pass
    
    @abstractmethod
    def get_workflow_status(self, workflow_id: UUID) -> Dict[str, Any]:
        """获取工作流状态"""
        pass
```

## 5. 依赖注入容器配置

### 5.1 IoC容器设计

```python
from typing import Dict, Type, Any, Callable
from enum import Enum

class ServiceLifetime(Enum):
    """服务生命周期"""
    SINGLETON = "singleton"
    TRANSIENT = "transient"
    SCOPED = "scoped"

class DIContainer:
    """依赖注入容器"""
    
    def __init__(self):
        self._services: Dict[Type, Any] = {}
        self._factories: Dict[Type, Callable] = {}
        self._lifetimes: Dict[Type, ServiceLifetime] = {}
        self._instances: Dict[Type, Any] = {}
    
    def register_singleton(self, interface: Type, implementation: Type) -> None:
        """注册单例服务"""
        self._services[interface] = implementation
        self._lifetimes[interface] = ServiceLifetime.SINGLETON
    
    def register_transient(self, interface: Type, implementation: Type) -> None:
        """注册瞬态服务"""
        self._services[interface] = implementation
        self._lifetimes[interface] = ServiceLifetime.TRANSIENT
    
    def register_scoped(self, interface: Type, implementation: Type) -> None:
        """注册作用域服务"""
        self._services[interface] = implementation
        self._lifetimes[interface] = ServiceLifetime.SCOPED
    
    def register_factory(self, interface: Type, factory: Callable) -> None:
        """注册工厂方法"""
        self._factories[interface] = factory
    
    def resolve(self, interface: Type) -> Any:
        """解析服务"""
        if interface in self._factories:
            return self._factories[interface]()
        
        if interface not in self._services:
            raise ValueError(f"Service {interface} not registered")
        
        lifetime = self._lifetimes[interface]
        
        if lifetime == ServiceLifetime.SINGLETON:
            if interface not in self._instances:
                self._instances[interface] = self._create_instance(interface)
            return self._instances[interface]
        
        elif lifetime == ServiceLifetime.TRANSIENT:
            return self._create_instance(interface)
        
        elif lifetime == ServiceLifetime.SCOPED:
            # 简化实现，实际应该基于作用域
            return self._create_instance(interface)
    
    def _create_instance(self, interface: Type) -> Any:
        """创建实例"""
        implementation = self._services[interface]
        # 简化实现，实际应该处理构造函数依赖注入
        return implementation()
```

### 5.2 服务注册配置

```python
def configure_services(container: DIContainer) -> None:
    """配置服务注册"""
    
    # 注册仓储服务
    container.register_scoped(IKnowledgeBaseRepository, PostgreSQLKnowledgeBaseRepository)
    container.register_scoped(ITrainingJobRepository, PostgreSQLTrainingJobRepository)
    container.register_scoped(IEvaluationJobRepository, PostgreSQLEvaluationJobRepository)
    container.register_scoped(IWorkflowInstanceRepository, PostgreSQLWorkflowInstanceRepository)
    
    # 注册领域服务
    container.register_transient(IDocumentProcessingService, DocumentProcessingService)
    container.register_transient(IModelTrainingService, HuggingFaceTrainingService)
    container.register_transient(IQualityAssessmentService, QualityAssessmentService)
    container.register_transient(IInferenceService, InferenceService)
    
    # 注册基础设施服务
    container.register_singleton(IStorageService, FileSystemStorageService)
    container.register_singleton(IVectorStoreService, FAISSVectorStoreService)
    container.register_singleton(IMessageQueueService, RabbitMQService)
    container.register_singleton(INotificationService, EmailNotificationService)
    
    # 注册应用服务
    container.register_scoped(IKnowledgeManagementPort, KnowledgeManagementApplicationService)
    container.register_scoped(IModelTrainingPort, ModelTrainingApplicationService)
    container.register_scoped(IQualityAssessmentPort, QualityAssessmentApplicationService)
    container.register_scoped(IInferencePort, InferenceApplicationService)
    container.register_scoped(IWorkflowOrchestrationPort, WorkflowOrchestrationApplicationService)
```

## 6. 配置化依赖注入

### 6.1 配置文件格式

```yaml
# dependency_config.yaml
services:
  repositories:
    IKnowledgeBaseRepository:
      implementation: PostgreSQLKnowledgeBaseRepository
      lifetime: scoped
      config:
        connection_string: "postgresql://localhost:5432/knowledge_db"
    
    ITrainingJobRepository:
      implementation: PostgreSQLTrainingJobRepository
      lifetime: scoped
      config:
        connection_string: "postgresql://localhost:5432/training_db"
  
  domain_services:
    IDocumentProcessingService:
      implementation: DocumentProcessingService
      lifetime: transient
      config:
        max_file_size: 10485760  # 10MB
    
    IModelTrainingService:
      implementation: HuggingFaceTrainingService
      lifetime: transient
      config:
        api_key: "${HUGGINGFACE_API_KEY}"
        base_url: "https://api-inference.huggingface.co"
  
  infrastructure_services:
    IStorageService:
      implementation: FileSystemStorageService
      lifetime: singleton
      config:
        base_path: "/data/storage"
    
    IVectorStoreService:
      implementation: FAISSVectorStoreService
      lifetime: singleton
      config:
        index_path: "/data/vector_indices"
```

### 6.2 配置加载器

```python
import yaml
import os
from typing import Dict, Any

class ConfigurationLoader:
    """配置加载器"""
    
    @staticmethod
    def load_dependency_config(config_path: str) -> Dict[str, Any]:
        """加载依赖配置"""
        with open(config_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)
        
        # 处理环境变量替换
        ConfigurationLoader._replace_environment_variables(config)
        
        return config
    
    @staticmethod
    def _replace_environment_variables(config: Dict[str, Any]) -> None:
        """替换环境变量"""
        for key, value in config.items():
            if isinstance(value, dict):
                ConfigurationLoader._replace_environment_variables(value)
            elif isinstance(value, str) and value.startswith('${') and value.endswith('}'):
                env_var = value[2:-1]
                config[key] = os.getenv(env_var, value)

def configure_services_from_config(container: DIContainer, config_path: str) -> None:
    """从配置文件配置服务"""
    config = ConfigurationLoader.load_dependency_config(config_path)
    
    for category, services in config['services'].items():
        for interface_name, service_config in services.items():
            interface = globals()[interface_name]  # 简化实现
            implementation = globals()[service_config['implementation']]
            lifetime = ServiceLifetime(service_config['lifetime'])
            
            if lifetime == ServiceLifetime.SINGLETON:
                container.register_singleton(interface, implementation)
            elif lifetime == ServiceLifetime.TRANSIENT:
                container.register_transient(interface, implementation)
            elif lifetime == ServiceLifetime.SCOPED:
                container.register_scoped(interface, implementation)
```

## 7. 实现示例

### 7.1 应用服务实现示例

```python
class KnowledgeManagementApplicationService(IKnowledgeManagementPort):
    """知识管理应用服务实现"""
    
    def __init__(self, 
                 kb_repository: IKnowledgeBaseRepository,
                 doc_processing_service: IDocumentProcessingService,
                 vector_store_service: IVectorStoreService,
                 storage_service: IStorageService):
        self._kb_repository = kb_repository
        self._doc_processing_service = doc_processing_service
        self._vector_store_service = vector_store_service
        self._storage_service = storage_service
    
    def create_knowledge_base(self, name: str, description: str) -> UUID:
        """创建知识库"""
        # 检查名称唯一性
        existing_kb = self._kb_repository.find_by_name(name)
        if existing_kb:
            raise ValueError(f"Knowledge base with name '{name}' already exists")
        
        # 创建知识库聚合根
        kb = KnowledgeBase.create(name, description)
        
        # 保存到仓储
        self._kb_repository.save(kb)
        
        return kb.id
    
    def add_document(self, kb_id: UUID, document_data: Dict[str, Any]) -> UUID:
        """添加文档"""
        # 获取知识库
        kb = self._kb_repository.find_by_id(kb_id)
        if not kb:
            raise ValueError(f"Knowledge base with id '{kb_id}' not found")
        
        # 创建文档
        document = Document.create(
            title=document_data['title'],
            content=document_data['content'],
            file_type=document_data['file_type']
        )
        
        # 验证文档格式
        if not self._doc_processing_service.validate_document_format(document):
            raise ValueError("Invalid document format")
        
        # 添加到知识库
        kb.add_document(document)
        
        # 保存文档内容
        file_path = f"documents/{document.id}"
        self._storage_service.save_file(file_path, document_data['content'].encode())
        
        # 保存知识库
        self._kb_repository.save(kb)
        
        return document.id
```

### 7.2 基础设施层实现示例

```python
class PostgreSQLKnowledgeBaseRepository(IKnowledgeBaseRepository):
    """PostgreSQL知识库仓储实现"""
    
    def __init__(self, connection_string: str):
        self._connection_string = connection_string
        # 初始化数据库连接
    
    def save(self, entity: KnowledgeBase) -> None:
        """保存知识库"""
        # 实现数据库保存逻辑
        pass
    
    def find_by_id(self, entity_id: UUID) -> Optional[KnowledgeBase]:
        """根据ID查找知识库"""
        # 实现数据库查询逻辑
        pass
    
    def find_by_name(self, name: str) -> Optional[KnowledgeBase]:
        """根据名称查找知识库"""
        # 实现数据库查询逻辑
        pass
    
    def find_by_status(self, status: str) -> List[KnowledgeBase]:
        """根据状态查找知识库"""
        # 实现数据库查询逻辑
        pass
    
    def find_ready_for_training(self) -> List[KnowledgeBase]:
        """查找可用于训练的知识库"""
        # 实现业务查询逻辑
        pass
```

## 8. 总结

通过实施依赖倒置原则，我们实现了：

1. **清晰的依赖方向**：高层模块不依赖低层模块，都依赖于抽象
2. **松耦合架构**：各层通过接口交互，降低耦合度
3. **可测试性**：通过依赖注入，便于单元测试和集成测试
4. **可扩展性**：新的实现可以轻松替换现有实现
5. **配置化管理**：通过配置文件管理依赖关系
6. **生命周期管理**：支持不同的服务生命周期策略

这种设计确保了系统的高内聚、低耦合，为后续的维护和扩展奠定了坚实的基础。