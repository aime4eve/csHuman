# 微调生命周期工作流系统 - 洋葱模型架构文档

## 1. 架构概述

### 1.1 洋葱模型架构原理

洋葱模型架构（Onion Architecture）是一种以领域为中心的架构模式，通过层次化设计实现关注点分离和依赖倒置。该架构将系统分为多个同心圆层，内层定义抽象接口，外层实现具体细节。

### 1.2 核心设计原则

1. **依赖倒置**：外层依赖内层，内层不依赖外层
2. **关注点分离**：每层专注于特定职责
3. **接口隔离**：通过接口定义层间契约
4. **领域驱动**：以业务领域为核心
5. **可测试性**：支持单元测试和集成测试

## 2. 架构分层设计

```
┌─────────────────────────────────────────────────────────────┐
│                    基础设施层 (Infrastructure)                │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              适配器层 (Adapters)                    │    │
│  │  ┌─────────────────────────────────────────────┐   │    │
│  │  │            应用层 (Application)              │   │    │
│  │  │  ┌─────────────────────────────────────┐   │   │    │
│  │  │  │         领域层 (Domain)              │   │   │    │
│  │  │  │                                     │   │   │    │
│  │  │  │  ┌─────────────────────────────┐   │   │   │    │
│  │  │  │  │      领域核心 (Core)         │   │   │   │    │
│  │  │  │  │                             │   │   │   │    │
│  │  │  │  │  • 聚合根                   │   │   │   │    │
│  │  │  │  │  • 实体                     │   │   │   │    │
│  │  │  │  │  • 值对象                   │   │   │   │    │
│  │  │  │  │  • 领域事件                 │   │   │   │    │
│  │  │  │  └─────────────────────────────┘   │   │   │    │
│  │  │  │                                     │   │   │    │
│  │  │  │  • 领域服务                         │   │   │    │
│  │  │  │  • 仓储接口                         │   │   │    │
│  │  │  │  • 领域事件处理器                   │   │   │    │
│  │  │  └─────────────────────────────────────┘   │   │    │
│  │  │                                             │   │    │
│  │  │  • 应用服务                                 │   │    │
│  │  │  • 工作流编排                               │   │    │
│  │  │  • 命令处理器                               │   │    │
│  │  │  • 查询处理器                               │   │    │
│  │  └─────────────────────────────────────────────┘   │    │
│  │                                                     │    │
│  │  • 数据库适配器                                     │    │
│  │  • 外部服务适配器                                   │    │
│  │  • 消息队列适配器                                   │    │
│  │  • 防腐层                                           │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  • 数据库实现                                               │
│  • 文件系统                                                 │
│  • 外部API                                                  │
│  • 配置管理                                                 │
└─────────────────────────────────────────────────────────────┘
```

### 2.1 领域层 (Domain Layer)

**职责**：包含业务逻辑和领域知识

**组件**：
- **聚合根**：`KnowledgeBase`、`TrainingJob`、`EvaluationJob`
- **实体**：`Document`、`ModelVersion`、`WorkflowInstance`
- **值对象**：`TrainingConfig`、`EvaluationMetrics`、`DocumentMetadata`
- **领域服务**：`ModelTrainingService`、`QualityAssessmentService`
- **仓储接口**：`IKnowledgeBaseRepository`、`ITrainingJobRepository`
- **领域事件**：`TrainingStartedEvent`、`EvaluationCompletedEvent`

**依赖关系**：无外部依赖，完全自包含

### 2.2 应用层 (Application Layer)

**职责**：协调领域对象执行业务用例

**组件**：
- **应用服务**：`KnowledgeManagementService`、`ModelTrainingService`
- **命令处理器**：`CreateKnowledgeBaseHandler`、`StartTrainingHandler`
- **查询处理器**：`GetKnowledgeBaseHandler`、`GetTrainingStatusHandler`
- **工作流编排**：`TrainingWorkflowOrchestrator`
- **DTO**：`CreateKnowledgeBaseCommand`、`TrainingJobDto`

**依赖关系**：依赖领域层接口

### 2.3 适配器层 (Adapters Layer)

**职责**：实现端口接口，连接外部系统

**组件**：
- **数据库适配器**：`PostgreSQLKnowledgeBaseRepository`
- **外部服务适配器**：`HuggingFaceModelAdapter`、`OpenAIAdapter`
- **消息队列适配器**：`RabbitMQMessageAdapter`
- **防腐层**：`UnifiedModelService`、`UnifiedStorageService`
- **Web适配器**：`KnowledgeBaseController`、`TrainingController`

**依赖关系**：依赖应用层和领域层接口

### 2.4 基础设施层 (Infrastructure Layer)

**职责**：提供技术实现和外部资源

**组件**：
- **数据库**：PostgreSQL、Redis
- **消息队列**：RabbitMQ
- **文件存储**：本地文件系统、云存储
- **配置管理**：环境变量、配置文件
- **日志系统**：结构化日志
- **监控系统**：健康检查、指标收集

**依赖关系**：被适配器层使用

## 3. 依赖关系图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web Layer     │    │   CLI Layer     │    │   API Layer     │
│                 │    │                 │    │                 │
│ • Controllers   │    │ • Commands      │    │ • REST API      │
│ • Middleware    │    │ • CLI Handlers  │    │ • GraphQL       │
└─────────┬───────┘    └─────────┬───────┘    └─────────┬───────┘
          │                      │                      │
          └──────────────────────┼──────────────────────┘
                                 │
                                 ▼
          ┌─────────────────────────────────────────────────┐
          │              Application Layer                  │
          │                                                 │
          │ • Application Services                          │
          │ • Command Handlers                              │
          │ • Query Handlers                                │
          │ • Workflow Orchestrators                        │
          │ • DTOs                                          │
          └─────────────────────┬───────────────────────────┘
                                │
                                ▼
          ┌─────────────────────────────────────────────────┐
          │                Domain Layer                     │
          │                                                 │
          │ ┌─────────────────────────────────────────────┐ │
          │ │              Domain Core                    │ │
          │ │                                             │ │
          │ │ • Aggregates (KnowledgeBase, TrainingJob)   │ │
          │ │ • Entities (Document, ModelVersion)        │ │
          │ │ • Value Objects (Config, Metrics)          │ │
          │ │ • Domain Events                            │ │
          │ └─────────────────────────────────────────────┘ │
          │                                                 │
          │ • Domain Services                               │
          │ • Repository Interfaces                         │
          │ • Domain Event Handlers                         │
          └─────────────────────┬───────────────────────────┘
                                │
                                ▼
          ┌─────────────────────────────────────────────────┐
          │              Adapters Layer                     │
          │                                                 │
          │ • Database Adapters                             │
          │ • External Service Adapters                     │
          │ • Message Queue Adapters                        │
          │ • Anti-Corruption Layer                         │
          │ • Event Publishers                              │
          └─────────────────────┬───────────────────────────┘
                                │
                                ▼
          ┌─────────────────────────────────────────────────┐
          │            Infrastructure Layer                 │
          │                                                 │
          │ • Database (PostgreSQL, Redis)                 │
          │ • Message Queue (RabbitMQ)                     │
          │ • File Storage                                  │
          │ • External APIs (HuggingFace, OpenAI)          │
          │ • Configuration                                 │
          │ • Logging & Monitoring                          │
          └─────────────────────────────────────────────────┘
```

## 4. 端口和适配器模式

### 4.1 端口定义 (Ports)

端口是领域层定义的抽象接口，代表系统与外部世界的交互点。

#### 4.1.1 主端口 (Primary Ports)

```python
# 应用服务端口
class IKnowledgeManagementService(ABC):
    @abstractmethod
    async def create_knowledge_base(self, command: CreateKnowledgeBaseCommand) -> KnowledgeBaseDto:
        pass
    
    @abstractmethod
    async def upload_document(self, kb_id: UUID, document: DocumentUploadCommand) -> DocumentDto:
        pass

# 工作流编排端口
class IWorkflowOrchestrator(ABC):
    @abstractmethod
    async def start_training_workflow(self, job_id: UUID) -> WorkflowInstanceDto:
        pass
```

#### 4.1.2 次端口 (Secondary Ports)

```python
# 仓储端口
class IKnowledgeBaseRepository(ABC):
    @abstractmethod
    async def save(self, knowledge_base: KnowledgeBase) -> None:
        pass
    
    @abstractmethod
    async def find_by_id(self, kb_id: UUID) -> Optional[KnowledgeBase]:
        pass

# 外部服务端口
class IModelService(ABC):
    @abstractmethod
    async def fine_tune_model(self, config: TrainingConfig) -> ModelVersion:
        pass
```

### 4.2 适配器实现 (Adapters)

适配器实现端口接口，连接具体的外部系统。

#### 4.2.1 主适配器 (Primary Adapters)

```python
# Web适配器
class KnowledgeBaseController:
    def __init__(self, service: IKnowledgeManagementService):
        self.service = service
    
    async def create_knowledge_base(self, request: CreateKnowledgeBaseRequest) -> Response:
        command = CreateKnowledgeBaseCommand.from_request(request)
        result = await self.service.create_knowledge_base(command)
        return Response.success(result)

# CLI适配器
class KnowledgeBaseCLI:
    def __init__(self, service: IKnowledgeManagementService):
        self.service = service
    
    async def create_kb_command(self, name: str, description: str) -> None:
        command = CreateKnowledgeBaseCommand(name=name, description=description)
        result = await self.service.create_knowledge_base(command)
        print(f"Knowledge base created: {result.id}")
```

#### 4.2.2 次适配器 (Secondary Adapters)

```python
# 数据库适配器
class PostgreSQLKnowledgeBaseRepository(IKnowledgeBaseRepository):
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def save(self, knowledge_base: KnowledgeBase) -> None:
        table_entity = self._map_entity_to_table(knowledge_base)
        self.session.add(table_entity)
        await self.session.commit()

# 外部服务适配器
class HuggingFaceModelAdapter(IModelService):
    def __init__(self, api_key: str):
        self.client = HuggingFaceClient(api_key)
    
    async def fine_tune_model(self, config: TrainingConfig) -> ModelVersion:
        response = await self.client.create_fine_tuning_job(config.to_dict())
        return ModelVersion.from_external_response(response)
```

## 5. 防腐层设计

### 5.1 防腐层架构

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (Application)                     │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                   防腐层 (Anti-Corruption)                  │
│                                                             │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
│  │  统一模型服务    │  │  统一存储服务    │  │  统一消息   │ │
│  │                │  │                │  │    服务     │ │
│  │ • 接口标准化    │  │ • 接口标准化    │  │ • 接口标准化 │ │
│  │ • 数据转换      │  │ • 数据转换      │  │ • 数据转换   │ │
│  │ • 错误处理      │  │ • 错误处理      │  │ • 错误处理   │ │
│  │ • 降级策略      │  │ • 降级策略      │  │ • 降级策略   │ │
│  └─────────────────┘  └─────────────────┘  └─────────────┘ │
└─────────┬───────────────────┬───────────────────┬───────────┘
          │                   │                   │
          ▼                   ▼                   ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   模型服务适配器  │  │   存储服务适配器  │  │   消息服务适配器  │
│                │  │                │  │                │
│ • HuggingFace  │  │ • PostgreSQL   │  │ • RabbitMQ     │
│ • OpenAI       │  │ • FAISS        │  │ • Redis Pub/Sub│
│ • 本地模型      │  │ • 文件系统      │  │ • Kafka        │
└─────────────────┘  └─────────────────┘  └─────────────────┘
```

### 5.2 防腐层实现示例

```python
# 统一模型服务接口
class IUnifiedModelService(ABC):
    @abstractmethod
    async def fine_tune(self, request: UnifiedTrainingRequest) -> UnifiedTrainingResponse:
        pass
    
    @abstractmethod
    async def generate_embeddings(self, texts: List[str]) -> List[List[float]]:
        pass

# 防腐层实现
class UnifiedModelService(IUnifiedModelService):
    def __init__(self, adapters: Dict[str, IModelAdapter]):
        self.adapters = adapters
        self.fallback_adapter = adapters.get('local')
    
    async def fine_tune(self, request: UnifiedTrainingRequest) -> UnifiedTrainingResponse:
        try:
            # 选择适配器
            adapter = self._select_adapter(request.provider)
            
            # 转换请求格式
            provider_request = self._convert_request(request, adapter.get_format())
            
            # 调用外部服务
            response = await adapter.fine_tune(provider_request)
            
            # 转换响应格式
            return self._convert_response(response, adapter.get_format())
            
        except Exception as e:
            # 错误处理和降级
            return await self._handle_error_with_fallback(request, e)
    
    def _select_adapter(self, provider: str) -> IModelAdapter:
        if provider in self.adapters:
            return self.adapters[provider]
        return self.fallback_adapter
    
    def _convert_request(self, request: UnifiedTrainingRequest, format: str) -> Any:
        # 数据转换逻辑
        converter = RequestConverterFactory.create(format)
        return converter.convert(request)
    
    async def _handle_error_with_fallback(self, request: UnifiedTrainingRequest, error: Exception) -> UnifiedTrainingResponse:
        # 记录错误
        logger.error(f"Model service error: {error}")
        
        # 尝试降级策略
        if self.fallback_adapter:
            return await self.fallback_adapter.fine_tune(request)
        
        # 返回错误响应
        return UnifiedTrainingResponse.error(str(error))
```

## 6. 数据流和控制流

### 6.1 请求处理流程

```
1. 外部请求 → Web Controller (适配器层)
2. Controller → Application Service (应用层)
3. Application Service → Domain Service (领域层)
4. Domain Service → Repository Interface (领域层)
5. Repository Interface → Repository Implementation (适配器层)
6. Repository Implementation → Database (基础设施层)
```

### 6.2 事件处理流程

```
1. Domain Entity → Domain Event (领域层)
2. Domain Event → Event Handler (领域层)
3. Event Handler → Message Publisher Interface (领域层)
4. Message Publisher Interface → Message Adapter (适配器层)
5. Message Adapter → Message Queue (基础设施层)
```

## 7. 配置和依赖注入

### 7.1 依赖注入容器配置

```python
class DIContainer:
    def __init__(self):
        self._services = {}
        self._singletons = {}
    
    def configure_services(self):
        # 领域服务
        self.register_transient(IModelTrainingService, ModelTrainingService)
        self.register_transient(IQualityAssessmentService, QualityAssessmentService)
        
        # 应用服务
        self.register_transient(IKnowledgeManagementService, KnowledgeManagementService)
        self.register_transient(IModelTrainingService, ModelTrainingApplicationService)
        
        # 仓储
        self.register_scoped(IKnowledgeBaseRepository, PostgreSQLKnowledgeBaseRepository)
        self.register_scoped(ITrainingJobRepository, PostgreSQLTrainingJobRepository)
        
        # 外部服务
        self.register_singleton(IUnifiedModelService, UnifiedModelService)
        self.register_singleton(IUnifiedStorageService, UnifiedStorageService)
        
        # 基础设施
        self.register_singleton(DatabaseManager, DatabaseManager)
        self.register_singleton(ICacheService, RedisCacheService)
```

### 7.2 配置文件结构

```yaml
# config/application.yml
application:
  name: "Fine-tuning Lifecycle Workflow System"
  version: "1.0.0"
  
database:
  host: "localhost"
  port: 5432
  name: "finetuning_db"
  
services:
  model_providers:
    - name: "huggingface"
      enabled: true
      config:
        api_key: "${HUGGINGFACE_API_KEY}"
    - name: "openai"
      enabled: true
      config:
        api_key: "${OPENAI_API_KEY}"
  
  storage:
    primary: "postgresql"
    cache: "redis"
    
  messaging:
    provider: "rabbitmq"
    config:
      host: "localhost"
      port: 5672
```

## 8. 架构优势

### 8.1 可维护性
- **清晰的层次结构**：每层职责明确
- **松耦合设计**：通过接口隔离实现
- **易于理解**：符合直觉的依赖方向

### 8.2 可测试性
- **单元测试友好**：领域逻辑独立可测
- **Mock支持**：接口便于创建测试替身
- **集成测试隔离**：适配器层可独立测试

### 8.3 可扩展性
- **新功能添加**：在相应层次添加组件
- **外部系统集成**：通过适配器模式
- **技术栈替换**：更换基础设施层实现

### 8.4 业务对齐
- **领域驱动**：业务逻辑集中在领域层
- **业务语言**：使用统一的业务术语
- **业务规则**：在领域层明确表达

## 9. 实施指南

### 9.1 迁移策略
1. **识别聚合边界**：分析现有业务逻辑
2. **提取领域模型**：创建充血领域对象
3. **定义端口接口**：抽象外部依赖
4. **实现适配器**：连接外部系统
5. **重构应用服务**：移除业务逻辑
6. **添加防腐层**：隔离外部复杂性

### 9.2 最佳实践
1. **保持领域层纯净**：避免技术细节泄露
2. **使用工厂模式**：创建复杂聚合
3. **实现仓储模式**：抽象数据访问
4. **应用CQRS**：分离命令和查询
5. **使用领域事件**：实现松耦合通信
6. **编写架构测试**：验证依赖方向

## 10. 总结

洋葱模型架构为微调生命周期工作流系统提供了：

1. **清晰的架构边界**：每层职责明确，依赖方向清晰
2. **高度的可测试性**：支持单元测试、集成测试和架构测试
3. **良好的可维护性**：松耦合设计，易于修改和扩展
4. **强大的防腐能力**：隔离外部系统复杂性
5. **业务逻辑集中**：领域知识在领域层统一管理

通过这种架构设计，系统能够更好地应对业务变化和技术演进，确保长期的可维护性和可扩展性。