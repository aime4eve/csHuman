# 微调生命周期工作流系统 - 设计文档更新

## 1. 文档更新概述

本文档更新了微调生命周期工作流系统的设计，重点补充了洋葱模型架构相关内容，包括技术架构分层、防腐层设计和充血模型说明。

## 2. 洋葱模型架构章节

### 2.1 架构设计理念

#### 2.1.1 设计原则

微调生命周期工作流系统采用洋葱模型架构（Onion Architecture），遵循以下核心设计原则：

1. **依赖倒置原则 (DIP)**
   - 高层模块不依赖低层模块，两者都依赖抽象
   - 抽象不依赖细节，细节依赖抽象
   - 依赖方向：外层 → 内层

2. **单一职责原则 (SRP)**
   - 每个类只有一个引起变化的原因
   - 每层专注于特定的职责范围
   - 避免职责混合和耦合

3. **开闭原则 (OCP)**
   - 对扩展开放，对修改封闭
   - 通过接口和抽象实现可扩展性
   - 新功能通过新实现而非修改现有代码

4. **接口隔离原则 (ISP)**
   - 客户端不应依赖它不使用的接口
   - 接口应该小而专注
   - 避免胖接口和不必要的依赖

#### 2.1.2 架构优势

1. **业务逻辑保护**
   - 核心业务逻辑位于架构中心
   - 不受外部技术变化影响
   - 业务规则清晰表达

2. **技术无关性**
   - 业务逻辑独立于具体技术实现
   - 可以轻松替换数据库、框架等
   - 支持多种部署方式

3. **高可测试性**
   - 业务逻辑可独立测试
   - 外部依赖可轻松Mock
   - 支持TDD开发方式

4. **清晰的边界**
   - 层次边界明确
   - 职责分离清晰
   - 依赖关系简单

### 2.2 领域模型设计

#### 2.2.1 核心聚合

```python
# 知识库聚合根
class KnowledgeBase(AggregateRoot):
    """知识库聚合根 - 管理文档集合和配置"""
    
    def __init__(self, name: str, description: str, owner_id: UUID, config: KnowledgeBaseConfig):
        super().__init__()
        self._id = UUID4()
        self._name = KnowledgeBaseName(name)
        self._description = description
        self._owner_id = owner_id
        self._config = config
        self._documents: List[Document] = []
        self._status = KnowledgeBaseStatus.DRAFT
        self._created_at = datetime.utcnow()
        self._updated_at = datetime.utcnow()
    
    def add_document(self, document: Document) -> None:
        """添加文档到知识库"""
        if self._status != KnowledgeBaseStatus.ACTIVE:
            raise DomainException("Cannot add document to inactive knowledge base")
        
        if self._is_document_limit_exceeded():
            raise DomainException("Document limit exceeded")
        
        self._documents.append(document)
        self._updated_at = datetime.utcnow()
        
        # 发布领域事件
        self._add_domain_event(DocumentAddedEvent(
            knowledge_base_id=self._id,
            document_id=document.id,
            occurred_at=datetime.utcnow()
        ))
    
    def activate(self) -> None:
        """激活知识库"""
        if not self._documents:
            raise DomainException("Cannot activate empty knowledge base")
        
        self._status = KnowledgeBaseStatus.ACTIVE
        self._updated_at = datetime.utcnow()
        
        self._add_domain_event(KnowledgeBaseActivatedEvent(
            knowledge_base_id=self._id,
            occurred_at=datetime.utcnow()
        ))
    
    def _is_document_limit_exceeded(self) -> bool:
        """检查文档数量限制"""
        return len(self._documents) >= self._config.max_documents

# 训练任务聚合根
class TrainingJob(AggregateRoot):
    """训练任务聚合根 - 管理模型微调过程"""
    
    @classmethod
    def create_fine_tuning_job(cls, knowledge_base_id: UUID, base_model: str, 
                              training_config: TrainingConfig, owner_id: UUID) -> 'TrainingJob':
        """创建微调任务"""
        job = cls()
        job._id = UUID4()
        job._knowledge_base_id = knowledge_base_id
        job._base_model = BaseModel(base_model)
        job._training_config = training_config
        job._owner_id = owner_id
        job._status = TrainingStatus.PENDING
        job._created_at = datetime.utcnow()
        
        job._add_domain_event(TrainingJobCreatedEvent(
            job_id=job._id,
            knowledge_base_id=knowledge_base_id,
            occurred_at=datetime.utcnow()
        ))
        
        return job
    
    def start_training(self) -> None:
        """开始训练"""
        if self._status != TrainingStatus.PENDING:
            raise DomainException(f"Cannot start training from status: {self._status}")
        
        self._status = TrainingStatus.RUNNING
        self._started_at = datetime.utcnow()
        
        self._add_domain_event(TrainingStartedEvent(
            job_id=self._id,
            occurred_at=datetime.utcnow()
        ))
    
    def complete_training(self, model_version: ModelVersion, metrics: TrainingMetrics) -> None:
        """完成训练"""
        if self._status != TrainingStatus.RUNNING:
            raise DomainException(f"Cannot complete training from status: {self._status}")
        
        self._status = TrainingStatus.COMPLETED
        self._model_version = model_version
        self._metrics = metrics
        self._completed_at = datetime.utcnow()
        
        self._add_domain_event(TrainingCompletedEvent(
            job_id=self._id,
            model_version=model_version,
            metrics=metrics,
            occurred_at=datetime.utcnow()
        ))
```

#### 2.2.2 值对象设计

```python
# 训练配置值对象
@dataclass(frozen=True)
class TrainingConfig:
    """训练配置值对象"""
    learning_rate: float
    batch_size: int
    epochs: int
    warmup_steps: int
    weight_decay: float
    
    def __post_init__(self):
        if self.learning_rate <= 0 or self.learning_rate > 1:
            raise ValueError("Learning rate must be between 0 and 1")
        if self.batch_size <= 0:
            raise ValueError("Batch size must be positive")
        if self.epochs <= 0:
            raise ValueError("Epochs must be positive")

# 评估指标值对象
@dataclass(frozen=True)
class EvaluationMetrics:
    """评估指标值对象"""
    accuracy: float
    precision: float
    recall: float
    f1_score: float
    loss: float
    
    def __post_init__(self):
        for metric in [self.accuracy, self.precision, self.recall, self.f1_score]:
            if not 0 <= metric <= 1:
                raise ValueError("Metric values must be between 0 and 1")
    
    def is_better_than(self, other: 'EvaluationMetrics') -> bool:
        """比较指标是否更好"""
        return (self.f1_score > other.f1_score and 
                self.accuracy > other.accuracy)

# 文档元数据值对象
@dataclass(frozen=True)
class DocumentMetadata:
    """文档元数据值对象"""
    author: str
    created_date: date
    language: str
    tags: List[str]
    source: str
    
    def __post_init__(self):
        if not self.author.strip():
            raise ValueError("Author cannot be empty")
        if self.created_date > date.today():
            raise ValueError("Created date cannot be in the future")
```

#### 2.2.3 领域服务

```python
# 模型训练领域服务
class ModelTrainingService:
    """模型训练领域服务"""
    
    def __init__(self, quality_threshold: float = 0.8):
        self.quality_threshold = quality_threshold
    
    def can_start_training(self, knowledge_base: KnowledgeBase, training_job: TrainingJob) -> bool:
        """判断是否可以开始训练"""
        # 检查知识库状态
        if knowledge_base.status != KnowledgeBaseStatus.ACTIVE:
            return False
        
        # 检查文档数量
        if len(knowledge_base.documents) < 10:
            return False
        
        # 检查训练任务状态
        if training_job.status != TrainingStatus.PENDING:
            return False
        
        return True
    
    def calculate_training_duration(self, training_config: TrainingConfig, 
                                  document_count: int) -> timedelta:
        """计算预估训练时间"""
        base_time = timedelta(minutes=30)
        config_factor = training_config.epochs * training_config.batch_size / 100
        document_factor = document_count / 1000
        
        return base_time * (1 + config_factor + document_factor)
    
    def validate_training_config(self, config: TrainingConfig, base_model: str) -> List[str]:
        """验证训练配置"""
        issues = []
        
        # 检查学习率
        if config.learning_rate > 0.01:
            issues.append("Learning rate too high, may cause instability")
        
        # 检查批次大小
        if config.batch_size > 64:
            issues.append("Large batch size may require more memory")
        
        # 检查模型兼容性
        if base_model.startswith("gpt") and config.epochs > 5:
            issues.append("Too many epochs for GPT models may cause overfitting")
        
        return issues

# 质量评估领域服务
class QualityAssessmentService:
    """质量评估领域服务"""
    
    def assess_model_quality(self, metrics: EvaluationMetrics) -> QualityLevel:
        """评估模型质量等级"""
        if metrics.f1_score >= 0.9 and metrics.accuracy >= 0.9:
            return QualityLevel.EXCELLENT
        elif metrics.f1_score >= 0.8 and metrics.accuracy >= 0.8:
            return QualityLevel.GOOD
        elif metrics.f1_score >= 0.7 and metrics.accuracy >= 0.7:
            return QualityLevel.ACCEPTABLE
        else:
            return QualityLevel.POOR
    
    def recommend_improvements(self, metrics: EvaluationMetrics, 
                             training_config: TrainingConfig) -> List[str]:
        """推荐改进建议"""
        recommendations = []
        
        if metrics.accuracy < 0.7:
            recommendations.append("Consider increasing training epochs")
            recommendations.append("Review training data quality")
        
        if metrics.precision < metrics.recall:
            recommendations.append("Model tends to over-predict, consider adjusting threshold")
        elif metrics.recall < metrics.precision:
            recommendations.append("Model is too conservative, consider more training data")
        
        if metrics.loss > 1.0:
            recommendations.append("High loss indicates underfitting, increase model complexity")
        
        return recommendations
```

## 3. 技术架构分层更新

### 3.1 分层架构详细设计

#### 3.1.1 接口层 (Interface Layer)

```python
# Web API 控制器
class KnowledgeBaseController:
    """知识库Web API控制器"""
    
    def __init__(self, knowledge_service: IKnowledgeManagementService):
        self.knowledge_service = knowledge_service
    
    @route('/api/knowledge-bases', methods=['POST'])
    async def create_knowledge_base(self, request: CreateKnowledgeBaseRequest) -> Response:
        """创建知识库API"""
        try:
            # 请求验证
            request.validate()
            
            # 转换为命令
            command = CreateKnowledgeBaseCommand(
                name=request.name,
                description=request.description,
                owner_id=request.owner_id,
                config=request.config
            )
            
            # 执行业务逻辑
            result = await self.knowledge_service.create_knowledge_base(command)
            
            # 返回响应
            return Response.success(result, status_code=201)
            
        except ValidationError as e:
            return Response.error(str(e), status_code=400)
        except DomainException as e:
            return Response.error(str(e), status_code=422)
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            return Response.error("Internal server error", status_code=500)

# CLI 命令处理器
class KnowledgeBaseCLI:
    """知识库CLI命令处理器"""
    
    def __init__(self, knowledge_service: IKnowledgeManagementService):
        self.knowledge_service = knowledge_service
    
    @click.command()
    @click.option('--name', required=True, help='Knowledge base name')
    @click.option('--description', help='Knowledge base description')
    @click.option('--config-file', help='Configuration file path')
    async def create_kb(self, name: str, description: str, config_file: str):
        """创建知识库CLI命令"""
        try:
            # 加载配置
            config = self._load_config(config_file) if config_file else None
            
            # 创建命令
            command = CreateKnowledgeBaseCommand(
                name=name,
                description=description or "",
                owner_id=self._get_current_user_id(),
                config=config
            )
            
            # 执行命令
            result = await self.knowledge_service.create_knowledge_base(command)
            
            # 输出结果
            click.echo(f"Knowledge base created successfully: {result.id}")
            
        except Exception as e:
            click.echo(f"Error: {e}", err=True)
            sys.exit(1)
```

#### 3.1.2 应用层 (Application Layer)

```python
# 知识管理应用服务
class KnowledgeManagementService(IKnowledgeManagementService):
    """知识管理应用服务"""
    
    def __init__(self, 
                 kb_repository: IKnowledgeBaseRepository,
                 doc_repository: IDocumentRepository,
                 event_publisher: IEventPublisher,
                 unit_of_work: IUnitOfWork):
        self.kb_repository = kb_repository
        self.doc_repository = doc_repository
        self.event_publisher = event_publisher
        self.unit_of_work = unit_of_work
    
    async def create_knowledge_base(self, command: CreateKnowledgeBaseCommand) -> KnowledgeBaseDto:
        """创建知识库"""
        async with self.unit_of_work:
            # 检查名称唯一性
            existing = await self.kb_repository.find_by_name(command.name)
            if existing:
                raise DomainException(f"Knowledge base with name '{command.name}' already exists")
            
            # 创建聚合根
            knowledge_base = KnowledgeBase(
                name=command.name,
                description=command.description,
                owner_id=command.owner_id,
                config=command.config or KnowledgeBaseConfig.default()
            )
            
            # 保存到仓储
            await self.kb_repository.save(knowledge_base)
            
            # 发布领域事件
            await self._publish_domain_events(knowledge_base)
            
            # 提交事务
            await self.unit_of_work.commit()
            
            return KnowledgeBaseDto.from_entity(knowledge_base)
    
    async def upload_document(self, command: UploadDocumentCommand) -> DocumentDto:
        """上传文档"""
        async with self.unit_of_work:
            # 获取知识库
            knowledge_base = await self.kb_repository.find_by_id(command.knowledge_base_id)
            if not knowledge_base:
                raise DomainException("Knowledge base not found")
            
            # 创建文档实体
            document = Document(
                title=command.title,
                file_type=command.file_type,
                size_bytes=command.size_bytes,
                content=command.content,
                metadata=command.metadata
            )
            
            # 添加到知识库
            knowledge_base.add_document(document)
            
            # 保存更改
            await self.kb_repository.save(knowledge_base)
            await self.doc_repository.save(document)
            
            # 发布事件
            await self._publish_domain_events(knowledge_base)
            
            await self.unit_of_work.commit()
            
            return DocumentDto.from_entity(document)
    
    async def _publish_domain_events(self, aggregate: AggregateRoot):
        """发布领域事件"""
        for event in aggregate.domain_events:
            await self.event_publisher.publish(event)
        aggregate.clear_domain_events()

# 工作流编排服务
class TrainingWorkflowOrchestrator(IWorkflowOrchestrator):
    """训练工作流编排服务"""
    
    def __init__(self,
                 training_service: IModelTrainingService,
                 evaluation_service: IModelEvaluationService,
                 notification_service: INotificationService):
        self.training_service = training_service
        self.evaluation_service = evaluation_service
        self.notification_service = notification_service
    
    async def start_training_workflow(self, job_id: UUID) -> WorkflowInstanceDto:
        """启动训练工作流"""
        workflow = WorkflowInstance.create_training_workflow(job_id)
        
        try:
            # 步骤1：数据准备
            await self._prepare_training_data(workflow)
            
            # 步骤2：开始训练
            await self._start_model_training(workflow)
            
            # 步骤3：监控训练进度
            await self._monitor_training_progress(workflow)
            
            # 步骤4：评估模型
            await self._evaluate_trained_model(workflow)
            
            # 步骤5：发布通知
            await self._notify_completion(workflow)
            
            workflow.complete()
            
        except Exception as e:
            workflow.fail(str(e))
            await self._handle_workflow_failure(workflow, e)
        
        return WorkflowInstanceDto.from_entity(workflow)
```

#### 3.1.3 领域层 (Domain Layer)

领域层包含核心业务逻辑，已在前面章节详细描述。

#### 3.1.4 基础设施层 (Infrastructure Layer)

```python
# 数据库配置
class DatabaseConfiguration:
    """数据库配置"""
    
    def __init__(self, config: Dict[str, Any]):
        self.host = config['host']
        self.port = config['port']
        self.database = config['database']
        self.username = config['username']
        self.password = config['password']
        self.pool_size = config.get('pool_size', 10)
        self.max_overflow = config.get('max_overflow', 20)
    
    def get_connection_string(self) -> str:
        return f"postgresql+asyncpg://{self.username}:{self.password}@{self.host}:{self.port}/{self.database}"

# 消息队列配置
class MessageQueueConfiguration:
    """消息队列配置"""
    
    def __init__(self, config: Dict[str, Any]):
        self.host = config['host']
        self.port = config['port']
        self.username = config.get('username', 'guest')
        self.password = config.get('password', 'guest')
        self.virtual_host = config.get('virtual_host', '/')
        self.exchange = config.get('exchange', 'finetuning')
    
    def get_connection_url(self) -> str:
        return f"amqp://{self.username}:{self.password}@{self.host}:{self.port}/{self.virtual_host}"

# 缓存配置
class CacheConfiguration:
    """缓存配置"""
    
    def __init__(self, config: Dict[str, Any]):
        self.host = config['host']
        self.port = config['port']
        self.database = config.get('database', 0)
        self.password = config.get('password')
        self.ttl_seconds = config.get('ttl_seconds', 3600)
    
    def get_connection_url(self) -> str:
        auth = f":{self.password}@" if self.password else ""
        return f"redis://{auth}{self.host}:{self.port}/{self.database}"
```

## 4. 防腐层设计补充

### 4.1 防腐层模式实现

#### 4.1.1 适配器模式

```python
# 模型服务适配器接口
class IModelServiceAdapter(ABC):
    """模型服务适配器接口"""
    
    @abstractmethod
    async def fine_tune_model(self, request: Any) -> Any:
        pass
    
    @abstractmethod
    async def get_training_status(self, job_id: str) -> Any:
        pass
    
    @abstractmethod
    def get_request_format(self) -> str:
        pass
    
    @abstractmethod
    def get_response_format(self) -> str:
        pass

# HuggingFace适配器实现
class HuggingFaceModelAdapter(IModelServiceAdapter):
    """HuggingFace模型服务适配器"""
    
    def __init__(self, api_key: str, base_url: str = None):
        self.client = HuggingFaceClient(api_key, base_url)
    
    async def fine_tune_model(self, request: HuggingFaceTrainingRequest) -> HuggingFaceTrainingResponse:
        """调用HuggingFace微调API"""
        try:
            response = await self.client.create_fine_tuning_job(
                model=request.model,
                training_file=request.training_file,
                validation_file=request.validation_file,
                hyperparameters=request.hyperparameters
            )
            return HuggingFaceTrainingResponse.from_api_response(response)
        except HuggingFaceAPIError as e:
            raise ExternalServiceError(f"HuggingFace API error: {e}")
    
    async def get_training_status(self, job_id: str) -> HuggingFaceJobStatus:
        """获取训练状态"""
        response = await self.client.get_fine_tuning_job(job_id)
        return HuggingFaceJobStatus.from_api_response(response)
    
    def get_request_format(self) -> str:
        return "huggingface"
    
    def get_response_format(self) -> str:
        return "huggingface"

# OpenAI适配器实现
class OpenAIModelAdapter(IModelServiceAdapter):
    """OpenAI模型服务适配器"""
    
    def __init__(self, api_key: str):
        self.client = OpenAIClient(api_key)
    
    async def fine_tune_model(self, request: OpenAITrainingRequest) -> OpenAITrainingResponse:
        """调用OpenAI微调API"""
        try:
            response = await self.client.fine_tuning.jobs.create(
                training_file=request.training_file,
                model=request.model,
                hyperparameters=request.hyperparameters
            )
            return OpenAITrainingResponse.from_api_response(response)
        except OpenAIAPIError as e:
            raise ExternalServiceError(f"OpenAI API error: {e}")
    
    def get_request_format(self) -> str:
        return "openai"
    
    def get_response_format(self) -> str:
        return "openai"
```

#### 4.1.2 数据转换层

```python
# 请求转换器工厂
class RequestConverterFactory:
    """请求转换器工厂"""
    
    _converters = {
        'huggingface': HuggingFaceRequestConverter,
        'openai': OpenAIRequestConverter,
        'local': LocalModelRequestConverter
    }
    
    @classmethod
    def create(cls, format_type: str) -> IRequestConverter:
        if format_type not in cls._converters:
            raise ValueError(f"Unsupported format: {format_type}")
        return cls._converters[format_type]()

# 统一请求转换器接口
class IRequestConverter(ABC):
    """请求转换器接口"""
    
    @abstractmethod
    def convert(self, unified_request: UnifiedTrainingRequest) -> Any:
        pass

# HuggingFace请求转换器
class HuggingFaceRequestConverter(IRequestConverter):
    """HuggingFace请求转换器"""
    
    def convert(self, unified_request: UnifiedTrainingRequest) -> HuggingFaceTrainingRequest:
        """转换为HuggingFace格式"""
        return HuggingFaceTrainingRequest(
            model=unified_request.base_model,
            training_file=unified_request.training_data_path,
            validation_file=unified_request.validation_data_path,
            hyperparameters={
                'learning_rate_multiplier': unified_request.config.learning_rate,
                'n_epochs': unified_request.config.epochs,
                'batch_size': unified_request.config.batch_size
            }
        )

# 响应转换器
class ResponseConverterFactory:
    """响应转换器工厂"""
    
    _converters = {
        'huggingface': HuggingFaceResponseConverter,
        'openai': OpenAIResponseConverter,
        'local': LocalModelResponseConverter
    }
    
    @classmethod
    def create(cls, format_type: str) -> IResponseConverter:
        if format_type not in cls._converters:
            raise ValueError(f"Unsupported format: {format_type}")
        return cls._converters[format_type]()

class HuggingFaceResponseConverter(IResponseConverter):
    """HuggingFace响应转换器"""
    
    def convert(self, provider_response: HuggingFaceTrainingResponse) -> UnifiedTrainingResponse:
        """转换为统一格式"""
        return UnifiedTrainingResponse(
            job_id=provider_response.id,
            status=self._map_status(provider_response.status),
            model_id=provider_response.fine_tuned_model,
            created_at=provider_response.created_at,
            completed_at=provider_response.finished_at,
            error_message=provider_response.error
        )
    
    def _map_status(self, hf_status: str) -> TrainingStatus:
        """映射状态"""
        status_mapping = {
            'validating_files': TrainingStatus.PENDING,
            'queued': TrainingStatus.PENDING,
            'running': TrainingStatus.RUNNING,
            'succeeded': TrainingStatus.COMPLETED,
            'failed': TrainingStatus.FAILED,
            'cancelled': TrainingStatus.CANCELLED
        }
        return status_mapping.get(hf_status, TrainingStatus.UNKNOWN)
```

### 4.2 错误处理和降级策略

```python
# 统一错误处理
class AntiCorruptionErrorHandler:
    """防腐层错误处理器"""
    
    def __init__(self, fallback_adapter: IModelServiceAdapter = None):
        self.fallback_adapter = fallback_adapter
        self.circuit_breaker = CircuitBreaker()
    
    async def handle_with_fallback(self, 
                                 operation: Callable,
                                 request: UnifiedTrainingRequest) -> UnifiedTrainingResponse:
        """带降级的错误处理"""
        try:
            # 检查熔断器状态
            if self.circuit_breaker.is_open():
                return await self._execute_fallback(request)
            
            # 执行主要操作
            result = await operation()
            self.circuit_breaker.record_success()
            return result
            
        except ExternalServiceError as e:
            self.circuit_breaker.record_failure()
            logger.warning(f"External service error: {e}")
            
            # 尝试降级策略
            return await self._execute_fallback(request)
            
        except Exception as e:
            self.circuit_breaker.record_failure()
            logger.error(f"Unexpected error: {e}")
            raise AntiCorruptionLayerError(f"Operation failed: {e}")
    
    async def _execute_fallback(self, request: UnifiedTrainingRequest) -> UnifiedTrainingResponse:
        """执行降级策略"""
        if self.fallback_adapter:
            logger.info("Executing fallback strategy")
            return await self.fallback_adapter.fine_tune_model(request)
        else:
            return UnifiedTrainingResponse.error("Service temporarily unavailable")

# 熔断器实现
class CircuitBreaker:
    """熔断器"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitBreakerState.CLOSED
    
    def is_open(self) -> bool:
        """检查熔断器是否开启"""
        if self.state == CircuitBreakerState.OPEN:
            if time.time() - self.last_failure_time > self.timeout:
                self.state = CircuitBreakerState.HALF_OPEN
                return False
            return True
        return False
    
    def record_success(self):
        """记录成功"""
        self.failure_count = 0
        self.state = CircuitBreakerState.CLOSED
    
    def record_failure(self):
        """记录失败"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitBreakerState.OPEN
```

## 5. 充血模型说明补充

### 5.1 充血模型 vs 贫血模型

#### 5.1.1 贫血模型问题

传统的贫血模型将数据和行为分离，导致：
- 业务逻辑分散在服务层
- 领域对象只是数据容器
- 违反面向对象设计原则
- 难以维护和扩展

```python
# 贫血模型示例（避免使用）
class KnowledgeBaseData:
    """贫血的知识库数据对象"""
    def __init__(self):
        self.id = None
        self.name = None
        self.description = None
        self.status = None
        self.documents = []

class KnowledgeBaseService:
    """业务逻辑在服务层"""
    def add_document(self, kb_data: KnowledgeBaseData, document_data: DocumentData):
        # 业务逻辑分散在服务层
        if kb_data.status != 'ACTIVE':
            raise Exception("Cannot add document to inactive knowledge base")
        
        if len(kb_data.documents) >= 1000:
            raise Exception("Document limit exceeded")
        
        kb_data.documents.append(document_data)
```

#### 5.1.2 充血模型优势

充血模型将业务逻辑封装在领域对象内部：
- 业务逻辑集中在领域对象
- 更好的封装性
- 符合面向对象原则
- 易于测试和维护

```python
# 充血模型示例（推荐使用）
class KnowledgeBase(AggregateRoot):
    """充血的知识库聚合根"""
    
    def add_document(self, document: Document) -> None:
        """添加文档 - 业务逻辑在领域对象内部"""
        # 业务规则验证
        self._validate_can_add_document()
        
        # 执行业务逻辑
        self._documents.append(document)
        self._updated_at = datetime.utcnow()
        
        # 发布领域事件
        self._add_domain_event(DocumentAddedEvent(
            knowledge_base_id=self._id,
            document_id=document.id,
            occurred_at=datetime.utcnow()
        ))
    
    def _validate_can_add_document(self) -> None:
        """验证是否可以添加文档"""
        if self._status != KnowledgeBaseStatus.ACTIVE:
            raise DomainException("Cannot add document to inactive knowledge base")
        
        if len(self._documents) >= self._config.max_documents:
            raise DomainException("Document limit exceeded")
    
    def calculate_storage_usage(self) -> StorageUsage:
        """计算存储使用情况"""
        total_size = sum(doc.size_bytes for doc in self._documents)
        document_count = len(self._documents)
        
        return StorageUsage(
            total_size_bytes=total_size,
            document_count=document_count,
            usage_percentage=total_size / self._config.max_storage_bytes * 100
        )
```

### 5.2 充血模型实现指南

#### 5.2.1 业务逻辑封装

```python
class TrainingJob(AggregateRoot):
    """训练任务充血模型"""
    
    def update_progress(self, progress: TrainingProgress) -> None:
        """更新训练进度"""
        # 验证状态转换
        if not self._can_update_progress():
            raise DomainException("Cannot update progress in current status")
        
        # 更新进度
        self._progress = progress
        self._updated_at = datetime.utcnow()
        
        # 检查是否需要发布事件
        if progress.is_milestone():
            self._add_domain_event(TrainingMilestoneReachedEvent(
                job_id=self._id,
                milestone=progress.milestone,
                occurred_at=datetime.utcnow()
            ))
    
    def estimate_completion_time(self) -> datetime:
        """估算完成时间"""
        if not self._progress or self._progress.percentage == 0:
            return self._created_at + self._config.estimated_duration
        
        elapsed_time = datetime.utcnow() - self._started_at
        estimated_total_time = elapsed_time / (self._progress.percentage / 100)
        
        return self._started_at + estimated_total_time
    
    def _can_update_progress(self) -> bool:
        """检查是否可以更新进度"""
        return self._status in [TrainingStatus.RUNNING, TrainingStatus.PAUSED]
```

#### 5.2.2 不变量维护

```python
class Document(Entity):
    """文档实体"""
    
    def __init__(self, title: str, file_type: str, size_bytes: int, content: str):
        super().__init__()
        # 验证不变量
        self._validate_invariants(title, file_type, size_bytes, content)
        
        self._title = DocumentTitle(title)
        self._file_type = FileType(file_type)
        self._size_bytes = size_bytes
        self._content = content
        self._created_at = datetime.utcnow()
    
    def update_content(self, new_content: str) -> None:
        """更新内容"""
        if not new_content.strip():
            raise DomainException("Content cannot be empty")
        
        old_size = len(self._content.encode('utf-8'))
        new_size = len(new_content.encode('utf-8'))
        
        self._content = new_content
        self._size_bytes = new_size
        self._updated_at = datetime.utcnow()
        
        # 发布内容更新事件
        self._add_domain_event(DocumentContentUpdatedEvent(
            document_id=self._id,
            old_size=old_size,
            new_size=new_size,
            occurred_at=datetime.utcnow()
        ))
    
    def _validate_invariants(self, title: str, file_type: str, size_bytes: int, content: str):
        """验证领域不变量"""
        if not title.strip():
            raise DomainException("Document title cannot be empty")
        
        if size_bytes <= 0:
            raise DomainException("Document size must be positive")
        
        if size_bytes > 100 * 1024 * 1024:  # 100MB
            raise DomainException("Document size exceeds maximum limit")
        
        if not content.strip():
            raise DomainException("Document content cannot be empty")
```

## 6. 总结

通过本次设计文档更新，我们完善了微调生命周期工作流系统的架构设计：

1. **洋葱模型架构**：建立了清晰的分层结构和依赖关系
2. **技术架构分层**：详细设计了各层的职责和实现
3. **防腐层设计**：提供了外部系统集成的统一接口
4. **充血模型实现**：将业务逻辑封装在领域对象中

这种架构设计确保了系统的：
- **可维护性**：清晰的分层和职责分离
- **可测试性**：业务逻辑独立可测
- **可扩展性**：通过接口和适配器模式
- **业务对齐**：领域驱动的设计方法

系统现在具备了应对复杂业务需求和技术变化的能力，为长期发展奠定了坚实的架构基础。