# 测试策略调整实现

## 1. 概述

本文档详细描述了微调生命周期工作流系统在洋葱模型架构下的测试策略调整，包括单元测试、集成测试和架构测试的具体实现方案，确保系统的可靠性、可维护性和架构完整性。

## 2. 单元测试实现

### 2.1 领域模型测试框架

```python
import pytest
from unittest.mock import Mock, patch
from datetime import datetime, timedelta
from uuid import uuid4, UUID
from typing import List, Dict, Any

# 测试基类
class DomainTestBase:
    """领域测试基类"""
    
    def setup_method(self):
        """测试方法设置"""
        self.mock_event_publisher = Mock()
        self.test_user_id = uuid4()
        self.test_timestamp = datetime.now()
    
    def assert_domain_event_published(self, event_type: type, **kwargs):
        """断言领域事件已发布"""
        calls = self.mock_event_publisher.publish.call_args_list
        matching_calls = [
            call for call in calls 
            if isinstance(call[0][0], event_type)
        ]
        
        assert len(matching_calls) > 0, f"Expected {event_type.__name__} event to be published"
        
        if kwargs:
            event = matching_calls[-1][0][0]
            for key, value in kwargs.items():
                assert getattr(event, key) == value, f"Expected {key}={value}, got {getattr(event, key)}"
    
    def create_test_knowledge_base(self, **overrides) -> 'KnowledgeBase':
        """创建测试知识库"""
        defaults = {
            'name': f'Test KB {uuid4().hex[:8]}',
            'description': 'Test knowledge base',
            'owner_id': self.test_user_id,
            'tags': ['test'],
            'config': {'chunk_size': 1000}
        }
        defaults.update(overrides)
        
        return KnowledgeBase(
            id=uuid4(),
            **defaults
        )
```

### 2.2 聚合根业务逻辑测试

```python
class TestKnowledgeBaseAggregate(DomainTestBase):
    """知识库聚合根测试"""
    
    def test_create_knowledge_base_success(self):
        """测试成功创建知识库"""
        # Arrange
        name = "Test Knowledge Base"
        description = "Test description"
        owner_id = self.test_user_id
        tags = ["ai", "nlp"]
        config = {"chunk_size": 1000, "overlap": 200}
        
        # Act
        kb = KnowledgeBase(
            name=name,
            description=description,
            owner_id=owner_id,
            tags=tags,
            config=config
        )
        
        # Assert
        assert kb.name == name
        assert kb.description == description
        assert kb.owner_id == owner_id
        assert kb.tags == tags
        assert kb.config == config
        assert kb.status == "CREATED"
        assert kb.document_count == 0
        assert kb.total_size_bytes == 0
        assert isinstance(kb.id, UUID)
        assert isinstance(kb.created_at, datetime)
    
    def test_add_document_success(self):
        """测试成功添加文档"""
        # Arrange
        kb = self.create_test_knowledge_base()
        document = Document(
            title="Test Document",
            file_type="pdf",
            size_bytes=1024,
            metadata={"author": "Test Author"}
        )
        
        # Act
        kb.add_document(document)
        
        # Assert
        assert len(kb.documents) == 1
        assert kb.documents[0] == document
        assert kb.document_count == 1
        assert kb.total_size_bytes == 1024
        assert document.knowledge_base_id == kb.id
    
    def test_add_document_when_processing_should_fail(self):
        """测试处理中时添加文档应失败"""
        # Arrange
        kb = self.create_test_knowledge_base()
        kb._status = "PROCESSING"
        document = Document(
            title="Test Document",
            file_type="pdf",
            size_bytes=1024
        )
        
        # Act & Assert
        with pytest.raises(DomainException) as exc_info:
            kb.add_document(document)
        
        assert "Cannot add document" in str(exc_info.value)
        assert "PROCESSING" in str(exc_info.value)
    
    def test_start_processing_success(self):
        """测试成功开始处理"""
        # Arrange
        kb = self.create_test_knowledge_base()
        kb.add_document(Document("Test", "pdf", 1024))
        
        # Act
        kb.start_processing()
        
        # Assert
        assert kb.status == "PROCESSING"
        assert kb.processing_started_at is not None
    
    def test_start_processing_without_documents_should_fail(self):
        """测试无文档时开始处理应失败"""
        # Arrange
        kb = self.create_test_knowledge_base()
        
        # Act & Assert
        with pytest.raises(DomainException) as exc_info:
            kb.start_processing()
        
        assert "No documents" in str(exc_info.value)
    
    def test_complete_processing_success(self):
        """测试成功完成处理"""
        # Arrange
        kb = self.create_test_knowledge_base()
        kb.add_document(Document("Test", "pdf", 1024))
        kb.start_processing()
        
        vector_config = {
            "model": "text-embedding-ada-002",
            "dimension": 1536
        }
        
        # Act
        kb.complete_processing(vector_config)
        
        # Assert
        assert kb.status == "READY"
        assert kb.processing_completed_at is not None
        assert kb.vector_store_config == vector_config
    
    def test_calculate_quality_score(self):
        """测试计算质量分数"""
        # Arrange
        kb = self.create_test_knowledge_base()
        
        # 添加不同类型的文档
        kb.add_document(Document("Doc1", "pdf", 1024, {"quality": "high"}))
        kb.add_document(Document("Doc2", "txt", 512, {"quality": "medium"}))
        kb.add_document(Document("Doc3", "docx", 2048, {"quality": "high"}))
        
        # Act
        score = kb.calculate_quality_score()
        
        # Assert
        assert 0 <= score <= 100
        assert isinstance(score, (int, float))
    
    def test_get_processing_statistics(self):
        """测试获取处理统计信息"""
        # Arrange
        kb = self.create_test_knowledge_base()
        kb.add_document(Document("Doc1", "pdf", 1024))
        kb.add_document(Document("Doc2", "txt", 512))
        kb.start_processing()
        
        # Act
        stats = kb.get_processing_statistics()
        
        # Assert
        assert "total_documents" in stats
        assert "total_size_bytes" in stats
        assert "processing_duration" in stats
        assert "status" in stats
        assert stats["total_documents"] == 2
        assert stats["total_size_bytes"] == 1536
        assert stats["status"] == "PROCESSING"

class TestTrainingJobAggregate(DomainTestBase):
    """训练任务聚合根测试"""
    
    def test_create_fine_tuning_job_success(self):
        """测试成功创建微调任务"""
        # Arrange
        kb_id = uuid4()
        base_model = "gpt-3.5-turbo"
        config = {
            "learning_rate": 0.001,
            "batch_size": 32,
            "epochs": 10
        }
        
        # Act
        job = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=kb_id,
            base_model=base_model,
            training_config=config,
            owner_id=self.test_user_id
        )
        
        # Assert
        assert job.job_type == "FINE_TUNING"
        assert job.knowledge_base_id == kb_id
        assert job.base_model == base_model
        assert job.training_config == config
        assert job.status == "CREATED"
        assert job.progress_percentage == 0
        assert job.owner_id == self.test_user_id
    
    def test_start_training_success(self):
        """测试成功开始训练"""
        # Arrange
        job = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={"epochs": 10},
            owner_id=self.test_user_id
        )
        
        # Act
        job.start_training()
        
        # Assert
        assert job.status == "RUNNING"
        assert job.started_at is not None
        assert job.progress_percentage == 0
    
    def test_update_progress_success(self):
        """测试成功更新进度"""
        # Arrange
        job = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={"epochs": 10},
            owner_id=self.test_user_id
        )
        job.start_training()
        
        # Act
        job.update_progress(50, 5, {"loss": 0.5, "accuracy": 0.85})
        
        # Assert
        assert job.progress_percentage == 50
        assert job.current_epoch == 5
        assert job.resource_usage["loss"] == 0.5
        assert job.resource_usage["accuracy"] == 0.85
    
    def test_complete_training_success(self):
        """测试成功完成训练"""
        # Arrange
        job = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={"epochs": 10},
            owner_id=self.test_user_id
        )
        job.start_training()
        
        model_path = "/models/fine_tuned_model"
        
        # Act
        job.complete_training(model_path)
        
        # Assert
        assert job.status == "COMPLETED"
        assert job.completed_at is not None
        assert job.final_model_path == model_path
        assert job.progress_percentage == 100
    
    def test_fail_training_with_error(self):
        """测试训练失败"""
        # Arrange
        job = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={"epochs": 10},
            owner_id=self.test_user_id
        )
        job.start_training()
        
        error_message = "GPU memory insufficient"
        
        # Act
        job.fail_training(error_message)
        
        # Assert
        assert job.status == "FAILED"
        assert job.error_message == error_message
        assert job.completed_at is not None
    
    def test_create_checkpoint_success(self):
        """测试成功创建检查点"""
        # Arrange
        job = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={"epochs": 10},
            owner_id=self.test_user_id
        )
        job.start_training()
        
        # Act
        checkpoint = job.create_checkpoint(
            epoch=3,
            model_path="/checkpoints/epoch_3",
            metrics={"loss": 0.3, "accuracy": 0.9}
        )
        
        # Assert
        assert checkpoint.epoch == 3
        assert checkpoint.model_path == "/checkpoints/epoch_3"
        assert checkpoint.metrics["loss"] == 0.3
        assert len(job.checkpoints) == 1
    
    def test_estimate_completion_time(self):
        """测试估算完成时间"""
        # Arrange
        job = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={"epochs": 10},
            owner_id=self.test_user_id
        )
        job.start_training()
        
        # 模拟一些进度
        job.update_progress(30, 3, {})
        
        # Act
        estimated_time = job.estimate_completion_time()
        
        # Assert
        assert estimated_time is not None
        assert isinstance(estimated_time, timedelta)
```

### 2.3 领域服务测试

```python
class TestModelTrainingService(DomainTestBase):
    """模型训练服务测试"""
    
    def setup_method(self):
        super().setup_method()
        self.mock_model_adapter = Mock()
        self.mock_data_adapter = Mock()
        self.service = ModelTrainingService(
            model_adapter=self.mock_model_adapter,
            data_adapter=self.mock_data_adapter
        )
    
    def test_validate_training_config_success(self):
        """测试验证训练配置成功"""
        # Arrange
        config = {
            "learning_rate": 0.001,
            "batch_size": 32,
            "epochs": 10,
            "model_type": "transformer"
        }
        
        # Act
        result = self.service.validate_training_config(config)
        
        # Assert
        assert result.is_valid
        assert len(result.errors) == 0
    
    def test_validate_training_config_invalid_learning_rate(self):
        """测试验证无效学习率"""
        # Arrange
        config = {
            "learning_rate": -0.001,  # 无效值
            "batch_size": 32,
            "epochs": 10
        }
        
        # Act
        result = self.service.validate_training_config(config)
        
        # Assert
        assert not result.is_valid
        assert any("learning_rate" in error for error in result.errors)
    
    def test_estimate_training_time(self):
        """测试估算训练时间"""
        # Arrange
        kb = self.create_test_knowledge_base()
        kb.add_document(Document("Doc1", "pdf", 1024000))  # 1MB
        kb.add_document(Document("Doc2", "txt", 512000))   # 0.5MB
        
        config = {
            "epochs": 10,
            "batch_size": 32
        }
        
        # Act
        estimated_time = self.service.estimate_training_time(kb, config)
        
        # Assert
        assert isinstance(estimated_time, timedelta)
        assert estimated_time.total_seconds() > 0
    
    def test_prepare_training_data(self):
        """测试准备训练数据"""
        # Arrange
        kb = self.create_test_knowledge_base()
        kb.add_document(Document("Doc1", "pdf", 1024))
        
        self.mock_data_adapter.extract_training_data.return_value = [
            {"input": "Question 1", "output": "Answer 1"},
            {"input": "Question 2", "output": "Answer 2"}
        ]
        
        # Act
        training_data = self.service.prepare_training_data(kb)
        
        # Assert
        assert len(training_data) == 2
        assert training_data[0]["input"] == "Question 1"
        self.mock_data_adapter.extract_training_data.assert_called_once_with(kb)

class TestQualityAssessmentService(DomainTestBase):
    """质量评估服务测试"""
    
    def setup_method(self):
        super().setup_method()
        self.mock_model_adapter = Mock()
        self.service = QualityAssessmentService(
            model_adapter=self.mock_model_adapter
        )
    
    def test_assess_model_quality_success(self):
        """测试评估模型质量成功"""
        # Arrange
        model_path = "/models/test_model"
        test_data = [
            {"input": "What is AI?", "expected": "Artificial Intelligence"},
            {"input": "What is ML?", "expected": "Machine Learning"}
        ]
        
        self.mock_model_adapter.evaluate_model.return_value = {
            "accuracy": 0.85,
            "precision": 0.82,
            "recall": 0.88,
            "f1_score": 0.85
        }
        
        # Act
        quality_metrics = self.service.assess_model_quality(model_path, test_data)
        
        # Assert
        assert quality_metrics["accuracy"] == 0.85
        assert quality_metrics["precision"] == 0.82
        assert quality_metrics["recall"] == 0.88
        assert quality_metrics["f1_score"] == 0.85
        self.mock_model_adapter.evaluate_model.assert_called_once_with(model_path, test_data)
    
    def test_calculate_quality_grade(self):
        """测试计算质量等级"""
        # Arrange
        metrics = {
            "accuracy": 0.85,
            "precision": 0.82,
            "recall": 0.88,
            "f1_score": 0.85
        }
        
        # Act
        grade = self.service.calculate_quality_grade(metrics)
        
        # Assert
        assert grade in ["A", "B", "C", "D", "F"]
    
    def test_compare_models(self):
        """测试比较模型"""
        # Arrange
        baseline_metrics = {
            "accuracy": 0.80,
            "precision": 0.78,
            "recall": 0.82,
            "f1_score": 0.80
        }
        
        new_metrics = {
            "accuracy": 0.85,
            "precision": 0.82,
            "recall": 0.88,
            "f1_score": 0.85
        }
        
        # Act
        comparison = self.service.compare_models(baseline_metrics, new_metrics)
        
        # Assert
        assert comparison["accuracy_improvement"] == 0.05
        assert comparison["overall_improvement"] > 0
        assert comparison["is_better"]
```

### 2.4 值对象测试

```python
class TestValueObjects(DomainTestBase):
    """值对象测试"""
    
    def test_training_config_creation(self):
        """测试训练配置创建"""
        # Arrange & Act
        config = TrainingConfig(
            learning_rate=0.001,
            batch_size=32,
            epochs=10,
            model_type="transformer"
        )
        
        # Assert
        assert config.learning_rate == 0.001
        assert config.batch_size == 32
        assert config.epochs == 10
        assert config.model_type == "transformer"
    
    def test_training_config_validation(self):
        """测试训练配置验证"""
        # Act & Assert
        with pytest.raises(ValueError):
            TrainingConfig(
                learning_rate=-0.001,  # 无效值
                batch_size=32,
                epochs=10
            )
    
    def test_training_config_equality(self):
        """测试训练配置相等性"""
        # Arrange
        config1 = TrainingConfig(
            learning_rate=0.001,
            batch_size=32,
            epochs=10
        )
        
        config2 = TrainingConfig(
            learning_rate=0.001,
            batch_size=32,
            epochs=10
        )
        
        config3 = TrainingConfig(
            learning_rate=0.002,
            batch_size=32,
            epochs=10
        )
        
        # Assert
        assert config1 == config2
        assert config1 != config3
        assert hash(config1) == hash(config2)
        assert hash(config1) != hash(config3)
    
    def test_quality_metrics_creation(self):
        """测试质量指标创建"""
        # Arrange & Act
        metrics = QualityMetrics(
            accuracy=0.85,
            precision=0.82,
            recall=0.88,
            f1_score=0.85
        )
        
        # Assert
        assert metrics.accuracy == 0.85
        assert metrics.precision == 0.82
        assert metrics.recall == 0.88
        assert metrics.f1_score == 0.85
    
    def test_quality_metrics_validation(self):
        """测试质量指标验证"""
        # Act & Assert
        with pytest.raises(ValueError):
            QualityMetrics(
                accuracy=1.5,  # 超出范围
                precision=0.82,
                recall=0.88,
                f1_score=0.85
            )
```

### 2.5 领域事件测试

```python
class TestDomainEvents(DomainTestBase):
    """领域事件测试"""
    
    def test_knowledge_base_created_event(self):
        """测试知识库创建事件"""
        # Arrange
        kb_id = uuid4()
        name = "Test KB"
        owner_id = self.test_user_id
        
        # Act
        event = KnowledgeBaseCreatedEvent(
            knowledge_base_id=kb_id,
            name=name,
            owner_id=owner_id,
            occurred_at=self.test_timestamp
        )
        
        # Assert
        assert event.knowledge_base_id == kb_id
        assert event.name == name
        assert event.owner_id == owner_id
        assert event.occurred_at == self.test_timestamp
        assert event.event_type == "KnowledgeBaseCreated"
    
    def test_training_job_started_event(self):
        """测试训练任务开始事件"""
        # Arrange
        job_id = uuid4()
        kb_id = uuid4()
        
        # Act
        event = TrainingJobStartedEvent(
            job_id=job_id,
            knowledge_base_id=kb_id,
            job_type="FINE_TUNING",
            owner_id=self.test_user_id,
            occurred_at=self.test_timestamp
        )
        
        # Assert
        assert event.job_id == job_id
        assert event.knowledge_base_id == kb_id
        assert event.job_type == "FINE_TUNING"
        assert event.owner_id == self.test_user_id
    
    def test_evaluation_completed_event(self):
        """测试评估完成事件"""
        # Arrange
        eval_id = uuid4()
        model_id = uuid4()
        quality_score = 85.5
        
        # Act
        event = EvaluationCompletedEvent(
            evaluation_id=eval_id,
            model_id=model_id,
            quality_score=quality_score,
            grade="B",
            occurred_at=self.test_timestamp
        )
        
        # Assert
        assert event.evaluation_id == eval_id
        assert event.model_id == model_id
        assert event.quality_score == quality_score
        assert event.grade == "B"
```

## 3. 集成测试实现

### 3.1 适配器测试框架

```python
import pytest
from testcontainers.postgres import PostgresContainer
from testcontainers.redis import RedisContainer
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import redis

class IntegrationTestBase:
    """集成测试基类"""
    
    @pytest.fixture(scope="class")
    def postgres_container(self):
        """PostgreSQL测试容器"""
        with PostgresContainer("postgres:13") as postgres:
            yield postgres
    
    @pytest.fixture(scope="class")
    def redis_container(self):
        """Redis测试容器"""
        with RedisContainer("redis:6") as redis_container:
            yield redis_container
    
    @pytest.fixture
    def db_session(self, postgres_container):
        """数据库会话"""
        engine = create_engine(postgres_container.get_connection_url())
        Base.metadata.create_all(engine)
        
        SessionLocal = sessionmaker(bind=engine)
        session = SessionLocal()
        
        try:
            yield session
        finally:
            session.close()
    
    @pytest.fixture
    def redis_client(self, redis_container):
        """Redis客户端"""
        client = redis.Redis(
            host=redis_container.get_container_host_ip(),
            port=redis_container.get_exposed_port(6379),
            decode_responses=True
        )
        yield client
        client.flushall()
```

### 3.2 数据库适配器测试

```python
class TestPostgreSQLKnowledgeBaseRepository(IntegrationTestBase):
    """PostgreSQL知识库仓储测试"""
    
    def test_save_and_find_knowledge_base(self, db_session):
        """测试保存和查找知识库"""
        # Arrange
        repository = PostgreSQLKnowledgeBaseRepository(db_session)
        kb = KnowledgeBase(
            name="Test KB",
            description="Test description",
            owner_id=uuid4(),
            tags=["test"],
            config={"chunk_size": 1000}
        )
        
        # Act
        repository.save(kb)
        db_session.commit()
        
        found_kb = repository.find_by_id(kb.id)
        
        # Assert
        assert found_kb is not None
        assert found_kb.id == kb.id
        assert found_kb.name == kb.name
        assert found_kb.description == kb.description
        assert found_kb.owner_id == kb.owner_id
        assert found_kb.tags == kb.tags
        assert found_kb.config == kb.config
    
    def test_find_by_name(self, db_session):
        """测试根据名称查找"""
        # Arrange
        repository = PostgreSQLKnowledgeBaseRepository(db_session)
        kb = KnowledgeBase(
            name="Unique Test KB",
            description="Test",
            owner_id=uuid4()
        )
        repository.save(kb)
        db_session.commit()
        
        # Act
        found_kb = repository.find_by_name("Unique Test KB")
        
        # Assert
        assert found_kb is not None
        assert found_kb.id == kb.id
        assert found_kb.name == "Unique Test KB"
    
    def test_find_by_status(self, db_session):
        """测试根据状态查找"""
        # Arrange
        repository = PostgreSQLKnowledgeBaseRepository(db_session)
        
        kb1 = KnowledgeBase(name="KB1", owner_id=uuid4())
        kb1._status = "READY"
        
        kb2 = KnowledgeBase(name="KB2", owner_id=uuid4())
        kb2._status = "PROCESSING"
        
        kb3 = KnowledgeBase(name="KB3", owner_id=uuid4())
        kb3._status = "READY"
        
        repository.save(kb1)
        repository.save(kb2)
        repository.save(kb3)
        db_session.commit()
        
        # Act
        ready_kbs = repository.find_by_status("READY")
        
        # Assert
        assert len(ready_kbs) == 2
        assert all(kb.status == "READY" for kb in ready_kbs)
    
    def test_complex_query_with_pagination(self, db_session):
        """测试复杂查询和分页"""
        # Arrange
        repository = OptimizedKnowledgeBaseRepository(db_session)
        
        # 创建测试数据
        for i in range(25):
            kb = KnowledgeBase(
                name=f"KB {i}",
                description=f"Description {i}",
                owner_id=uuid4(),
                tags=["test", f"tag{i % 3}"]
            )
            if i % 2 == 0:
                kb._status = "READY"
            repository.save(kb)
        
        db_session.commit()
        
        # Act
        search_params = {
            "statuses": ["READY"],
            "page": 1,
            "page_size": 10,
            "sort_by": "created_at",
            "sort_order": "desc"
        }
        
        result = repository.search_knowledge_bases(search_params)
        
        # Assert
        assert len(result["items"]) <= 10
        assert result["total_count"] >= 12  # 至少12个READY状态的KB
        assert result["page"] == 1
        assert result["page_size"] == 10
        assert all(kb.status == "READY" for kb in result["items"])
    
    def test_statistics_query(self, db_session):
        """测试统计查询"""
        # Arrange
        repository = PostgreSQLKnowledgeBaseRepository(db_session)
        
        # 创建测试数据
        for i in range(5):
            kb = KnowledgeBase(name=f"KB {i}", owner_id=uuid4())
            kb._document_count = i + 1
            kb._total_size_bytes = (i + 1) * 1000
            if i < 3:
                kb._status = "READY"
            repository.save(kb)
        
        db_session.commit()
        
        # Act
        stats = repository.get_statistics()
        
        # Assert
        assert stats["total_knowledge_bases"] == 5
        assert stats["total_documents"] == 15  # 1+2+3+4+5
        assert stats["total_size_bytes"] == 15000  # 1000+2000+3000+4000+5000
        assert stats["ready_knowledge_bases"] == 3

class TestTrainingJobRepository(IntegrationTestBase):
    """训练任务仓储测试"""
    
    def test_save_and_find_training_job(self, db_session):
        """测试保存和查找训练任务"""
        # Arrange
        repository = PostgreSQLTrainingJobRepository(db_session)
        job = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={"epochs": 10},
            owner_id=uuid4()
        )
        
        # Act
        repository.save(job)
        db_session.commit()
        
        found_job = repository.find_by_id(job.id)
        
        # Assert
        assert found_job is not None
        assert found_job.id == job.id
        assert found_job.job_type == "FINE_TUNING"
        assert found_job.base_model == "gpt-3.5-turbo"
        assert found_job.training_config == {"epochs": 10}
    
    def test_find_active_jobs(self, db_session):
        """测试查找活跃任务"""
        # Arrange
        repository = PostgreSQLTrainingJobRepository(db_session)
        
        # 创建不同状态的任务
        job1 = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={},
            owner_id=uuid4()
        )
        job1._status = "RUNNING"
        
        job2 = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={},
            owner_id=uuid4()
        )
        job2._status = "COMPLETED"
        
        job3 = TrainingJob.create_fine_tuning_job(
            knowledge_base_id=uuid4(),
            base_model="gpt-3.5-turbo",
            training_config={},
            owner_id=uuid4()
        )
        job3._status = "PENDING"
        
        repository.save(job1)
        repository.save(job2)
        repository.save(job3)
        db_session.commit()
        
        # Act
        active_jobs = repository.find_active_jobs()
        
        # Assert
        assert len(active_jobs) == 2
        active_statuses = {job.status for job in active_jobs}
        assert active_statuses == {"RUNNING", "PENDING"}
```

### 3.3 外部服务适配器测试

```python
class TestHuggingFaceModelAdapter(IntegrationTestBase):
    """HuggingFace模型适配器测试"""
    
    @pytest.fixture
    def mock_hf_client(self):
        """模拟HuggingFace客户端"""
        with patch('transformers.AutoTokenizer') as mock_tokenizer, \
             patch('transformers.AutoModel') as mock_model:
            
            mock_tokenizer.from_pretrained.return_value = Mock()
            mock_model.from_pretrained.return_value = Mock()
            
            yield {
                'tokenizer': mock_tokenizer,
                'model': mock_model
            }
    
    def test_load_model_success(self, mock_hf_client):
        """测试成功加载模型"""
        # Arrange
        adapter = HuggingFaceModelAdapter()
        model_name = "bert-base-uncased"
        
        # Act
        result = adapter.load_model(model_name)
        
        # Assert
        assert result.is_success
        mock_hf_client['tokenizer'].from_pretrained.assert_called_with(model_name)
        mock_hf_client['model'].from_pretrained.assert_called_with(model_name)
    
    def test_fine_tune_model(self, mock_hf_client):
        """测试微调模型"""
        # Arrange
        adapter = HuggingFaceModelAdapter()
        training_data = [
            {"input": "Question 1", "output": "Answer 1"},
            {"input": "Question 2", "output": "Answer 2"}
        ]
        config = {
            "learning_rate": 0.001,
            "batch_size": 16,
            "epochs": 3
        }
        
        # Act
        result = adapter.fine_tune_model(
            base_model="bert-base-uncased",
            training_data=training_data,
            config=config
        )
        
        # Assert
        assert result.is_success
        assert "model_path" in result.data
    
    def test_evaluate_model(self, mock_hf_client):
        """测试评估模型"""
        # Arrange
        adapter = HuggingFaceModelAdapter()
        model_path = "/models/test_model"
        test_data = [
            {"input": "Test input", "expected": "Test output"}
        ]
        
        # Mock evaluation results
        with patch.object(adapter, '_run_evaluation') as mock_eval:
            mock_eval.return_value = {
                "accuracy": 0.85,
                "precision": 0.82,
                "recall": 0.88,
                "f1_score": 0.85
            }
            
            # Act
            metrics = adapter.evaluate_model(model_path, test_data)
            
            # Assert
            assert metrics["accuracy"] == 0.85
            assert metrics["f1_score"] == 0.85
            mock_eval.assert_called_once_with(model_path, test_data)

class TestPostgreSQLStorageAdapter(IntegrationTestBase):
    """PostgreSQL存储适配器测试"""
    
    def test_store_and_retrieve_data(self, db_session):
        """测试存储和检索数据"""
        # Arrange
        adapter = PostgreSQLStorageAdapter(db_session)
        data = {
            "key": "test_key",
            "value": "test_value",
            "metadata": {"type": "test"}
        }
        
        # Act
        storage_id = adapter.store(data)
        retrieved_data = adapter.retrieve(storage_id)
        
        # Assert
        assert retrieved_data is not None
        assert retrieved_data["key"] == "test_key"
        assert retrieved_data["value"] == "test_value"
        assert retrieved_data["metadata"]["type"] == "test"
    
    def test_query_with_filters(self, db_session):
        """测试带过滤条件的查询"""
        # Arrange
        adapter = PostgreSQLStorageAdapter(db_session)
        
        # 存储测试数据
        for i in range(5):
            data = {
                "key": f"key_{i}",
                "value": f"value_{i}",
                "metadata": {"category": "test" if i % 2 == 0 else "prod"}
            }
            adapter.store(data)
        
        # Act
        filters = {"metadata.category": "test"}
        results = adapter.query(filters)
        
        # Assert
        assert len(results) == 3  # 0, 2, 4
        assert all(r["metadata"]["category"] == "test" for r in results)
```

### 3.4 消息队列适配器测试

```python
class TestRabbitMQMessageAdapter(IntegrationTestBase):
    """RabbitMQ消息适配器测试"""
    
    @pytest.fixture
    def mock_rabbitmq(self):
        """模拟RabbitMQ连接"""
        with patch('pika.BlockingConnection') as mock_conn:
            mock_channel = Mock()
            mock_conn.return_value.channel.return_value = mock_channel
            yield mock_channel
    
    def test_publish_message(self, mock_rabbitmq):
        """测试发布消息"""
        # Arrange
        adapter = RabbitMQMessageAdapter()
        message = {
            "type": "TrainingJobStarted",
            "data": {"job_id": str(uuid4())}
        }
        
        # Act
        result = adapter.publish("training.events", message)
        
        # Assert
        assert result.is_success
        mock_rabbitmq.basic_publish.assert_called_once()
    
    def test_subscribe_to_messages(self, mock_rabbitmq):
        """测试订阅消息"""
        # Arrange
        adapter = RabbitMQMessageAdapter()
        received_messages = []
        
        def message_handler(message):
            received_messages.append(message)
        
        # Mock incoming message
        mock_rabbitmq.basic_consume.side_effect = lambda queue, callback, auto_ack: \
            callback(None, None, None, b'{"type": "test", "data": {}}')
        
        # Act
        adapter.subscribe("test.queue", message_handler)
        
        # Assert
        mock_rabbitmq.basic_consume.assert_called_once()
```

### 3.5 防腐层测试

```python
class TestAntiCorruptionLayer(IntegrationTestBase):
    """防腐层测试"""
    
    def test_unified_model_service_with_different_providers(self):
        """测试统一模型服务与不同提供商"""
        # Arrange
        hf_adapter = Mock()
        openai_adapter = Mock()
        
        hf_adapter.load_model.return_value = AdapterResult(True, {"model": "hf_model"})
        openai_adapter.load_model.return_value = AdapterResult(True, {"model": "openai_model"})
        
        unified_service = UnifiedModelService({
            "huggingface": hf_adapter,
            "openai": openai_adapter
        })
        
        # Act
        hf_result = unified_service.load_model("bert-base-uncased", provider="huggingface")
        openai_result = unified_service.load_model("gpt-3.5-turbo", provider="openai")
        
        # Assert
        assert hf_result.is_success
        assert openai_result.is_success
        hf_adapter.load_model.assert_called_with("bert-base-uncased")
        openai_adapter.load_model.assert_called_with("gpt-3.5-turbo")
    
    def test_data_transformation_layer(self):
        """测试数据转换层"""
        # Arrange
        transformer = DTOTransformer()
        
        # 领域实体
        kb = KnowledgeBase(
            name="Test KB",
            description="Test",
            owner_id=uuid4()
        )
        
        # Act
        dto = transformer.to_dto(kb)
        restored_entity = transformer.from_dto(dto, KnowledgeBase)
        
        # Assert
        assert dto["name"] == "Test KB"
        assert dto["description"] == "Test"
        assert restored_entity.name == kb.name
        assert restored_entity.description == kb.description
        assert restored_entity.owner_id == kb.owner_id
    
    def test_error_handling_and_fallback(self):
        """测试错误处理和降级"""
        # Arrange
        primary_adapter = Mock()
        fallback_adapter = Mock()
        
        primary_adapter.load_model.side_effect = Exception("Primary service down")
        fallback_adapter.load_model.return_value = AdapterResult(True, {"model": "fallback_model"})
        
        resilient_service = ResilientModelService(
            primary=primary_adapter,
            fallback=fallback_adapter
        )
        
        # Act
        result = resilient_service.load_model("test-model")
        
        # Assert
        assert result.is_success
        assert result.data["model"] == "fallback_model"
        primary_adapter.load_model.assert_called_once()
        fallback_adapter.load_model.assert_called_once()
```

## 4. 架构测试实现

### 4.1 依赖方向测试

```python
import ast
import os
from pathlib import Path
from typing import Set, Dict, List

class ArchitectureTest:
    """架构测试"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.layers = {
            "domain": self.project_root / "domain",
            "application": self.project_root / "application", 
            "infrastructure": self.project_root / "infrastructure",
            "interfaces": self.project_root / "interfaces"
        }
    
    def test_dependency_direction(self):
        """测试依赖方向正确性"""
        violations = []
        
        # 领域层不应依赖其他层
        domain_deps = self._get_layer_dependencies("domain")
        invalid_domain_deps = domain_deps & {"application", "infrastructure", "interfaces"}
        if invalid_domain_deps:
            violations.append(f"Domain layer depends on: {invalid_domain_deps}")
        
        # 应用层不应依赖基础设施层和接口层
        app_deps = self._get_layer_dependencies("application")
        invalid_app_deps = app_deps & {"infrastructure", "interfaces"}
        if invalid_app_deps:
            violations.append(f"Application layer depends on: {invalid_app_deps}")
        
        # 基础设施层不应依赖接口层
        infra_deps = self._get_layer_dependencies("infrastructure")
        invalid_infra_deps = infra_deps & {"interfaces"}
        if invalid_infra_deps:
            violations.append(f"Infrastructure layer depends on: {invalid_infra_deps}")
        
        assert len(violations) == 0, f"Dependency violations found: {violations}"
    
    def test_circular_dependencies(self):
        """测试循环依赖"""
        dependency_graph = self._build_dependency_graph()
        cycles = self._find_cycles(dependency_graph)
        
        assert len(cycles) == 0, f"Circular dependencies found: {cycles}"
    
    def test_interface_segregation(self):
        """测试接口隔离"""
        violations = []
        
        # 检查接口是否过大
        for layer_name, layer_path in self.layers.items():
            interfaces = self._find_interfaces(layer_path)
            
            for interface_file, methods in interfaces.items():
                if len(methods) > 10:  # 接口方法数量阈值
                    violations.append(
                        f"Interface {interface_file} has {len(methods)} methods (>10)"
                    )
        
        assert len(violations) == 0, f"Interface segregation violations: {violations}"
    
    def test_layer_boundaries(self):
        """测试层次边界"""
        violations = []
        
        # 检查是否有跨层直接访问
        for layer_name, layer_path in self.layers.items():
            files = self._get_python_files(layer_path)
            
            for file_path in files:
                imports = self._extract_imports(file_path)
                
                for import_stmt in imports:
                    if self._is_cross_layer_violation(layer_name, import_stmt):
                        violations.append(
                            f"{file_path} has invalid import: {import_stmt}"
                        )
        
        assert len(violations) == 0, f"Layer boundary violations: {violations}"
    
    def _get_layer_dependencies(self, layer_name: str) -> Set[str]:
        """获取层的依赖"""
        dependencies = set()
        layer_path = self.layers[layer_name]
        
        if not layer_path.exists():
            return dependencies
        
        files = self._get_python_files(layer_path)
        
        for file_path in files:
            imports = self._extract_imports(file_path)
            
            for import_stmt in imports:
                for other_layer in self.layers:
                    if other_layer != layer_name and other_layer in import_stmt:
                        dependencies.add(other_layer)
        
        return dependencies
    
    def _get_python_files(self, directory: Path) -> List[Path]:
        """获取Python文件列表"""
        if not directory.exists():
            return []
        
        return list(directory.rglob("*.py"))
    
    def _extract_imports(self, file_path: Path) -> List[str]:
        """提取文件的导入语句"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = ast.parse(content)
            imports = []
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.append(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.append(node.module)
            
            return imports
        except Exception:
            return []
    
    def _build_dependency_graph(self) -> Dict[str, Set[str]]:
        """构建依赖图"""
        graph = {}
        
        for layer_name in self.layers:
            graph[layer_name] = self._get_layer_dependencies(layer_name)
        
        return graph
    
    def _find_cycles(self, graph: Dict[str, Set[str]]) -> List[List[str]]:
        """查找循环依赖"""
        def dfs(node, path, visited, rec_stack):
            visited.add(node)
            rec_stack.add(node)
            path.append(node)
            
            for neighbor in graph.get(node, set()):
                if neighbor in rec_stack:
                    # 找到循环
                    cycle_start = path.index(neighbor)
                    return [path[cycle_start:] + [neighbor]]
                elif neighbor not in visited:
                    cycles = dfs(neighbor, path, visited, rec_stack)
                    if cycles:
                        return cycles
            
            path.pop()
            rec_stack.remove(node)
            return []
        
        visited = set()
        all_cycles = []
        
        for node in graph:
            if node not in visited:
                cycles = dfs(node, [], visited, set())
                all_cycles.extend(cycles)
        
        return all_cycles
    
    def _find_interfaces(self, layer_path: Path) -> Dict[str, List[str]]:
        """查找接口及其方法"""
        interfaces = {}
        
        if not layer_path.exists():
            return interfaces
        
        files = self._get_python_files(layer_path)
        
        for file_path in files:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                tree = ast.parse(content)
                
                for node in ast.walk(tree):
                    if isinstance(node, ast.ClassDef):
                        # 检查是否是接口（抽象基类）
                        if self._is_interface_class(node):
                            methods = []
                            for item in node.body:
                                if isinstance(item, ast.FunctionDef):
                                    methods.append(item.name)
                            
                            interfaces[str(file_path)] = methods
            except Exception:
                continue
        
        return interfaces
    
    def _is_interface_class(self, class_node: ast.ClassDef) -> bool:
        """判断是否是接口类"""
        # 检查是否继承自ABC或有@abstractmethod装饰器
        for base in class_node.bases:
            if isinstance(base, ast.Name) and base.id == 'ABC':
                return True
        
        for item in class_node.body:
            if isinstance(item, ast.FunctionDef):
                for decorator in item.decorator_list:
                    if isinstance(decorator, ast.Name) and decorator.id == 'abstractmethod':
                        return True
        
        return False
    
    def _is_cross_layer_violation(self, current_layer: str, import_stmt: str) -> bool:
        """检查是否违反跨层访问规则"""
        # 定义允许的依赖关系
        allowed_dependencies = {
            "interfaces": {"application", "domain"},
            "application": {"domain"},
            "infrastructure": {"domain", "application"},
            "domain": set()
        }
        
        allowed = allowed_dependencies.get(current_layer, set())
        
        for layer in self.layers:
            if layer != current_layer and layer in import_stmt:
                if layer not in allowed:
                    return True
        
        return False

# 具体测试用例
class TestArchitecture:
    """架构测试用例"""
    
    def setup_method(self):
        self.arch_test = ArchitectureTest("/path/to/project")
    
    def test_onion_architecture_dependencies(self):
        """测试洋葱架构依赖关系"""
        self.arch_test.test_dependency_direction()
    
    def test_no_circular_dependencies(self):
        """测试无循环依赖"""
        self.arch_test.test_circular_dependencies()
    
    def test_interface_segregation_principle(self):
        """测试接口隔离原则"""
        self.arch_test.test_interface_segregation()
    
    def test_layer_boundary_integrity(self):
        """测试层边界完整性"""
        self.arch_test.test_layer_boundaries()
```

## 5. 测试配置和运行

### 5.1 pytest配置

```ini
# pytest.ini
[tool:pytest]
minversion = 6.0
addopts = 
    -ra
    -q
    --strict-markers
    --strict-config
    --cov=src
    --cov-report=term-missing
    --cov-report=html
    --cov-report=xml
    --cov-fail-under=80
testpaths = tests
markers =
    unit: Unit tests
    integration: Integration tests
    architecture: Architecture tests
    slow: Slow running tests
    external: Tests that require external services
```

### 5.2 测试运行脚本

```bash
#!/bin/bash
# run_tests.sh

# 设置环境变量
export PYTHONPATH="${PYTHONPATH}:$(pwd)/src"
export TEST_ENV="test"

# 运行单元测试
echo "Running unit tests..."
pytest tests/unit -m "unit" --cov=src/domain --cov=src/application

# 运行集成测试
echo "Running integration tests..."
pytest tests/integration -m "integration" --cov=src/infrastructure

# 运行架构测试
echo "Running architecture tests..."
pytest tests/architecture -m "architecture"

# 生成测试报告
echo "Generating test reports..."
pytest --html=reports/test_report.html --self-contained-html

# 检查覆盖率
echo "Checking code coverage..."
coverage report --fail-under=80
coverage html -d reports/coverage
```

### 5.3 CI/CD集成

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: Run unit tests
      run: |
        pytest tests/unit -m "unit" --cov=src
    
    - name: Run integration tests
      run: |
        pytest tests/integration -m "integration"
      env:
        DATABASE_URL: postgresql://postgres:test@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379/0
    
    - name: Run architecture tests
      run: |
        pytest tests/architecture -m "architecture"
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: true
```

## 6. 测试数据管理

### 6.1 测试数据工厂

```python
class TestDataFactory:
    """测试数据工厂"""
    
    @staticmethod
    def create_knowledge_base(**overrides) -> KnowledgeBase:
        """创建测试知识库"""
        defaults = {
            'name': f'Test KB {uuid4().hex[:8]}',
            'description': 'Test knowledge base for testing',
            'owner_id': uuid4(),
            'tags': ['test', 'automation'],
            'config': {
                'chunk_size': 1000,
                'overlap': 200,
                'embedding_model': 'text-embedding-ada-002'
            }
        }
        defaults.update(overrides)
        return KnowledgeBase(**defaults)
    
    @staticmethod
    def create_training_job(**overrides) -> TrainingJob:
        """创建测试训练任务"""
        defaults = {
            'knowledge_base_id': uuid4(),
            'base_model': 'gpt-3.5-turbo',
            'training_config': {
                'learning_rate': 0.001,
                'batch_size': 32,
                'epochs': 10
            },
            'owner_id': uuid4()
        }
        defaults.update(overrides)
        return TrainingJob.create_fine_tuning_job(**defaults)
    
    @staticmethod
    def create_document(**overrides) -> Document:
        """创建测试文档"""
        defaults = {
            'title': f'Test Document {uuid4().hex[:8]}',
            'file_type': 'pdf',
            'size_bytes': 1024000,
            'metadata': {
                'author': 'Test Author',
                'created_date': '2024-01-01',
                'language': 'en'
            }
        }
        defaults.update(overrides)
        return Document(**defaults)
```

### 6.2 测试数据清理

```python
class TestDataCleaner:
    """测试数据清理器"""
    
    def __init__(self, db_session):
        self.db_session = db_session
    
    def cleanup_all(self):
        """清理所有测试数据"""
        # 按依赖关系顺序删除
        tables = [
            'evaluation_jobs',
            'training_jobs', 
            'documents',
            'knowledge_bases',
            'workflow_instances'
        ]
        
        for table in tables:
            self.db_session.execute(f"DELETE FROM {table} WHERE id LIKE 'test-%'")
        
        self.db_session.commit()
    
    def cleanup_by_owner(self, owner_id: UUID):
        """按所有者清理测试数据"""
        # 删除特定用户的测试数据
        self.db_session.query(KnowledgeBaseTable).filter(
            KnowledgeBaseTable.owner_id == owner_id
        ).delete()
        
        self.db_session.query(TrainingJobTable).filter(
            TrainingJobTable.owner_id == owner_id
        ).delete()
        
        self.db_session.commit()
```

## 7. 性能测试

### 7.1 负载测试

```python
import time
import concurrent.futures
from typing import List, Callable

class PerformanceTest:
    """性能测试"""
    
    def __init__(self, repository):
        self.repository = repository
    
    def test_concurrent_operations(self, operation: Callable, 
                                 concurrent_count: int = 10,
                                 iterations: int = 100):
        """测试并发操作性能"""
        def run_operation():
            start_time = time.time()
            for _ in range(iterations):
                operation()
            return time.time() - start_time
        
        # 并发执行
        with concurrent.futures.ThreadPoolExecutor(max_workers=concurrent_count) as executor:
            futures = [executor.submit(run_operation) for _ in range(concurrent_count)]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]
        
        # 计算统计信息
        total_operations = concurrent_count * iterations
        total_time = max(results)
        avg_time = sum(results) / len(results)
        ops_per_second = total_operations / total_time
        
        return {
            'total_operations': total_operations,
            'total_time': total_time,
            'average_time': avg_time,
            'operations_per_second': ops_per_second
        }
    
    def test_repository_performance(self):
        """测试仓储性能"""
        # 创建测试数据
        test_entities = []
        for i in range(1000):
            kb = TestDataFactory.create_knowledge_base(
                name=f'Performance Test KB {i}'
            )
            test_entities.append(kb)
        
        # 测试批量保存
        start_time = time.time()
        for entity in test_entities:
            self.repository.save(entity)
        save_time = time.time() - start_time
        
        # 测试批量查询
        start_time = time.time()
        all_entities = self.repository.find_all()
        query_time = time.time() - start_time
        
        return {
            'save_time': save_time,
            'query_time': query_time,
            'entities_count': len(all_entities)
        }
```

## 8. 总结

通过测试策略调整，我们实现了：

1. **全面的单元测试**：覆盖领域模型、服务、值对象和事件
2. **完整的集成测试**：验证适配器、防腐层和外部服务集成
3. **严格的架构测试**：确保依赖方向、层次边界和接口隔离
4. **自动化测试流程**：CI/CD集成和测试报告生成
5. **性能测试支持**：并发操作和负载测试
6. **测试数据管理**：工厂模式和清理机制

这种测试策略确保了洋葱模型架构的正确实现和系统的高质量交付。